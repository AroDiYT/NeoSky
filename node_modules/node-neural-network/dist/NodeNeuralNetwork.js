(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
})({1:[function(require,module,exports){
/*

The MIT License (MIT)

Copyright (c) 2014 Juan Cazala - Lucas Bertola

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE



********************************************************************************************
                                         node-neural-network
********************************************************************************************

Node-neural-network is a javascript neural network library for node.js and the browser, its generalized
algorithm is architecture-free, so you can build and train basically any type of first order
or even second order neural network architectures.

http://en.wikipedia.org/wiki/Recurrent_neural_network#Second_Order_Recurrent_Neural_Network

The library includes a few built-in architectures like multilayer perceptrons, multilayer
long-short term memory networks (LSTM) or liquid state machines, and a trainer capable of
training any given network, and includes built-in training tasks/tests like solving an XOR,
passing a Distracted Sequence Recall test or an Embeded Reber Grammar test.

The algorithm implemented by this library has been taken from Derek D. Monner's paper:

A generalized LSTM-like training algorithm for second-order recurrent neural networks
http://www.overcomplete.net/papers/nn2012.pdf

There are references to the equations in that paper commented through the source code.


********************************************************************************************/
/*global define*/
/*eslint no-undef: ["error", { "typeof": true }] */
var NodeNeuralNetwork = {
    Neuron: require('./neuron'),
    Layer: require('./layer'),
    Network: require('./network'),
    Trainer: require('./trainer'),
    Architect: require('./architect')
};
// CommonJS & AMD
if (typeof define !== 'undefined' && define.amd) {
    define([], function () {
        return NodeNeuralNetwork;
    });
}
// Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = NodeNeuralNetwork;
}
// Browser
if (typeof window == 'object') {
    (function () {
        var oldNodeNeuralNetwork = window.NodeNeuralNetwork;
        NodeNeuralNetwork.ninja = function () {
            window.NodeNeuralNetwork = oldNodeNeuralNetwork;
            return NodeNeuralNetwork;
        };
    }());
    window.NodeNeuralNetwork = NodeNeuralNetwork;
}
},{"./architect":2,"./layer":3,"./network":4,"./neuron":5,"./trainer":6}],2:[function(require,module,exports){
/*jslint bitwise: true */
'use strict';
// import
var Layer = require('./layer');
var Network = require('./network');
var Trainer = require('./trainer');
/*******************************************************************************************
                                        ARCHITECT
*******************************************************************************************/
// Colection of useful built-in architectures
var Architect = {
    // Multilayer Perceptron
    Perceptron: function Perceptron() {
        var args = Array.prototype.slice.call(arguments);
        // convert arguments to Array
        if (args.length < 3) {
            throw new Error('not enough layers (minimum 3) !!');
        }
        var inputs = args.shift();
        // first argument
        var outputs = args.pop();
        // last argument
        var layers = args;
        // all the arguments in the middle
        var input = new Layer(inputs);
        var hidden = [];
        var output = new Layer(outputs);
        var previous = input;
        // generate hidden layers
        var level;
        var size;
        var layer;
        for (level in layers) {
            if (layers.hasOwnProperty(level)) {
                size = layers[level];
                layer = new Layer(size);
                hidden.push(layer);
                previous.project(layer);
                previous = layer;
            }
        }
        previous.project(output);
        // set layers of the neural network
        this.set({
            input: input,
            hidden: hidden,
            output: output
        });
        // trainer for the network
        this.trainer = new Trainer(this);
    },
    // Multilayer Long Short-Term Memory
    LSTM: function LSTM() {
        var args = Array.prototype.slice.call(arguments);
        // convert arguments to array
        if (args.length < 3) {
            throw new Error('not enough layers (minimum 3) !!');
        }
        var last = args.pop();
        var option = {
            peepholes: Layer.connectionType.ALL_TO_ALL,
            hiddenToHidden: false,
            outputToHidden: false,
            outputToGates: false,
            inputToOutput: true
        };
        var outputs;
        if (typeof last !== 'number') {
            outputs = args.pop();
            if (last.hasOwnProperty('peepholes')) {
                option.peepholes = last.peepholes;
            }
            if (last.hasOwnProperty('hiddenToHidden')) {
                option.hiddenToHidden = last.hiddenToHidden;
            }
            if (last.hasOwnProperty('outputToHidden')) {
                option.outputToHidden = last.outputToHidden;
            }
            if (last.hasOwnProperty('outputToGates')) {
                option.outputToGates = last.outputToGates;
            }
            if (last.hasOwnProperty('inputToOutput')) {
                option.inputToOutput = last.inputToOutput;
            }
        } else {
            outputs = last;
        }
        var inputs = args.shift();
        var layers = args;
        var inputLayer = new Layer(inputs);
        var hiddenLayers = [];
        var outputLayer = new Layer(outputs);
        var previous = null;
        // generate layers
        var layer;
        var size;
        var forgetGate;
        var inputGate;
        var memoryCell;
        var outputGate;
        var input;
        var output;
        var self;
        var cell;
        for (layer in layers) {
            if (layers.hasOwnProperty(layer)) {
                // generate memory blocks (memory cell and respective gates)
                size = layers[layer];
                inputGate = new Layer(size).set({
                    bias: 1
                });
                forgetGate = new Layer(size).set({
                    bias: 1
                });
                memoryCell = new Layer(size);
                outputGate = new Layer(size).set({
                    bias: 1
                });
                hiddenLayers.push(inputGate);
                hiddenLayers.push(forgetGate);
                hiddenLayers.push(memoryCell);
                hiddenLayers.push(outputGate);
                // connections from input layer
                input = inputLayer.project(memoryCell);
                inputLayer.project(inputGate);
                inputLayer.project(forgetGate);
                inputLayer.project(outputGate);
                // connections from previous memory-block layer to this one
                if (previous !== null) {
                    cell = previous.project(memoryCell);
                    previous.project(inputGate);
                    previous.project(forgetGate);
                    previous.project(outputGate);
                }
                // connections from memory cell
                output = memoryCell.project(outputLayer);
                // self-connection
                self = memoryCell.project(memoryCell);
                // hidden to hidden recurrent connection
                if (option.hiddenToHidden) {
                    memoryCell.project(memoryCell, Layer.connectionType.ALL_TO_ELSE);
                }
                // out to hidden recurrent connection
                if (option.outputToHidden) {
                    outputLayer.project(memoryCell);
                }
                // out to gates recurrent connection
                if (option.outputToGates) {
                    outputLayer.project(inputGate);
                    outputLayer.project(outputGate);
                    outputLayer.project(forgetGate);
                }
                // peepholes
                memoryCell.project(inputGate, option.peepholes);
                memoryCell.project(forgetGate, option.peepholes);
                memoryCell.project(outputGate, option.peepholes);
                // gates
                inputGate.gate(input, Layer.gateType.INPUT);
                forgetGate.gate(self, Layer.gateType.ONE_TO_ONE);
                outputGate.gate(output, Layer.gateType.OUTPUT);
                if (previous !== null) {
                    inputGate.gate(cell, Layer.gateType.INPUT);
                }
                previous = memoryCell;
            }
        }
        // input to output direct connection
        if (option.inputToOutput) {
            inputLayer.project(outputLayer);
        }
        // set the layers of the neural network
        this.set({
            input: inputLayer,
            hidden: hiddenLayers,
            output: outputLayer
        });
        // trainer
        this.trainer = new Trainer(this);
    },
    // Liquid State Machine
    Liquid: function Liquid(inputs, hidden, outputs, connections, gates) {
        // create layers
        var inputLayer = new Layer(inputs);
        var hiddenLayer = new Layer(hidden);
        var outputLayer = new Layer(outputs);
        // make connections and gates randomly among the neurons
        var neurons = hiddenLayer.neurons();
        var connectionList = [];
        var i;
        var from;
        var to;
        var connection;
        for (i = 0; i < connections; i = i + 1) {
            // connect two random neurons
            from = Math.random() * neurons.length | 0;
            to = Math.random() * neurons.length | 0;
            connection = neurons[from].project(neurons[to]);
            connectionList.push(connection);
        }
        var j;
        var gater;
        for (j = 0; j < gates; j = j + 1) {
            // pick a random gater neuron
            gater = Math.random() * neurons.length | 0;
            // pick a random connection to gate
            connection = Math.random() * connectionList.length | 0;
            // let the gater gate the connection
            neurons[gater].gate(connectionList[connection]);
        }
        // connect the layers
        inputLayer.project(hiddenLayer);
        hiddenLayer.project(outputLayer);
        // set the layers of the network
        this.set({
            input: inputLayer,
            hidden: [hiddenLayer],
            output: outputLayer
        });
        // trainer
        this.trainer = new Trainer(this);
    },
    Hopfield: function Hopfield(size) {
        var inputLayer = new Layer(size);
        var outputLayer = new Layer(size);
        inputLayer.project(outputLayer, Layer.connectionType.ALL_TO_ALL);
        this.set({
            input: inputLayer,
            hidden: [],
            output: outputLayer
        });
        var trainer = new Trainer(this);
        var proto = Architect.Hopfield.prototype;
        proto.learn = proto.learn || function (patterns) {
            var set = [];
            var p;
            for (p in patterns) {
                if (patterns.hasOwnProperty(p)) {
                    set.push({
                        input: patterns[p],
                        output: patterns[p]
                    });
                }
            }
            return trainer.train(set, {
                iterations: 500000,
                error: 0.00005,
                rate: 1
            });
        };
        proto.feed = proto.feed || function (pattern) {
            var output = this.activate(pattern);
            pattern = [];
            var i;
            for (i in output) {
                if (output.hasOwnProperty(i)) {
                    pattern[i] = output[i] > 0.5 ? 1 : 0;
                }
            }
            return pattern;
        };
    }
};
// Extend prototype chain (so every architectures is an instance of Network)
var architecture;
for (architecture in Architect) {
    if (Architect.hasOwnProperty(architecture)) {
        Architect[architecture].prototype = new Network();
        Architect[architecture].prototype.constructor = Architect[architecture];
    }
}
// export
if (module) {
    module.exports = Architect;
}
},{"./layer":3,"./network":4,"./trainer":6}],3:[function(require,module,exports){
'use strict';
/*global Layer*/
/*jslint bitwise: true */
// export
if (module) {
    //CHECK THIS GLOBAL VAR
    module.exports = Layer;
}
// import
var Neuron = require('./neuron');
var Network = require('./network');
/*******************************************************************************************
                                            LAYER
*******************************************************************************************/
function Layer(size) {
    this.size = size || 0;
    this.listNeurons = [];
    this.connectedTo = [];
    var neuronAdded;
    for (neuronAdded = 0; neuronAdded < this.size; neuronAdded = neuronAdded + 1) {
        this.listNeurons.push(new Neuron());
    }
}
Layer.prototype = {
    // activates all the neurons in the layer
    activate: function (input) {
        var activations = [];
        var id;
        var neuron;
        var activation;
        if (input !== undefined) {
            if (input.length !== this.size) {
                throw new Error('INPUT size and LAYER size must be the same to activate!');
            }
            for (id in this.listNeurons) {
                if (this.listNeurons.hasOwnProperty(id)) {
                    neuron = this.listNeurons[id];
                    activation = neuron.activate(input[id]);
                    activations.push(activation);
                }
            }
        } else {
            for (id in this.listNeurons) {
                if (this.listNeurons.hasOwnProperty(id)) {
                    neuron = this.listNeurons[id];
                    activation = neuron.activate();
                    activations.push(activation);
                }
            }
        }
        return activations;
    },
    // propagates the error on all the neurons of the layer
    propagate: function (rate, target) {
        var id;
        var neuron;
        if (target !== undefined) {
            if (target.length !== this.size) {
                throw new Error('TARGET size and LAYER size must be the same to propagate!');
            }
            for (id = this.listNeurons.length - 1; id >= 0; id = id - 1) {
                neuron = this.listNeurons[id];
                neuron.propagate(rate, target[id]);
            }
        } else {
            for (id = this.listNeurons.length - 1; id >= 0; id = id - 1) {
                neuron = this.listNeurons[id];
                neuron.propagate(rate);
            }
        }
    },
    // projects a connection from this layer to another one
    project: function (layer, type, weights) {
        if (layer instanceof Network) {
            layer = layer.layers.input;
        }
        if (layer instanceof Layer) {
            if (!this.connected(layer)) {
                return new Layer.connection(this, layer, type, weights);
            }
        } else {
            throw new Error('Invalid argument, you can only project connections to LAYERS and NETWORKS!');
        }
    },
    // gates a connection betwenn two layers
    gate: function (connection, type) {
        var id;
        var neuron;
        var gater;
        var gated;
        var input;
        var projected;
        if (type === Layer.gateType.INPUT) {
            if (connection.to.size !== this.size) {
                throw new Error('GATER layer and CONNECTION.TO layer must be the same size in order to gate!');
            }
            for (id in connection.to.listNeurons) {
                if (connection.to.listNeurons.hasOwnProperty(id)) {
                    neuron = connection.to.listNeurons[id];
                    gater = this.listNeurons[id];
                    for (input in neuron.connections.inputs) {
                        if (neuron.connections.inputs.hasOwnProperty(input)) {
                            gated = neuron.connections.inputs[input];
                            if (connection.connections.hasOwnProperty(gated.ID)) {
                                gater.gate(gated);
                            }
                        }
                    }
                }
            }
        } else if (type === Layer.gateType.OUTPUT) {
            if (connection.from.size !== this.size) {
                throw new Error('GATER layer and CONNECTION.FROM layer must be the same size in order to gate!');
            }
            for (id in connection.from.listNeurons) {
                if (connection.from.listNeurons.hasOwnProperty(id)) {
                    neuron = connection.from.listNeurons[id];
                    gater = this.listNeurons[id];
                    for (projected in neuron.connections.projected) {
                        if (neuron.connections.projected.hasOwnProperty(projected)) {
                            gated = neuron.connections.projected[projected];
                            if (connection.connections.hasOwnProperty(gated.ID)) {
                                gater.gate(gated);
                            }
                        }
                    }
                }
            }
        } else if (type === Layer.gateType.ONE_TO_ONE) {
            if (connection.size !== this.size) {
                throw new Error('The number of GATER UNITS must be the same as the number of CONNECTIONS to gate!');
            }
            for (id in connection.list) {
                if (connection.list.hasOwnProperty(id)) {
                    gater = this.listNeurons[id];
                    gated = connection.list[id];
                    gater.gate(gated);
                }
            }
        }
        connection.gatedfrom.push({
            layer: this,
            type: type
        });
    },
    // true or false whether the whole layer is self-connected or not
    selfconnected: function () {
        var id;
        var neuron;
        for (id in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(id)) {
                neuron = this.listNeurons[id];
                if (!neuron.selfconnected()) {
                    return false;
                }
            }
        }
        return true;
    },
    // true of false whether the layer is connected to another layer (parameter) or not
    connected: function (layer) {
        // Check if ALL to ALL connection
        var connections = 0;
        var here;
        var from;
        var to;
        var connected;
        var there;
        for (here in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(here)) {
                for (there in layer.listNeurons) {
                    if (layer.listNeurons.hasOwnProperty(there)) {
                        from = this.listNeurons[here];
                        to = layer.listNeurons[there];
                        connected = from.connected(to);
                        if (connected.type === 'projected') {
                            connections = connections + 1;
                        }
                    }
                }
            }
        }
        if (connections === this.size * layer.size) {
            return Layer.connectionType.ALL_TO_ALL;
        }
        // Check if ONE to ONE connection
        connections = 0;
        var neuron;
        for (neuron in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(neuron)) {
                from = this.listNeurons[neuron];
                to = layer.listNeurons[neuron];
                connected = from.connected(to);
                if (connected.type === 'projected') {
                    connections += 1;
                }
            }
        }
        if (connections === this.size) {
            return Layer.connectionType.ONE_TO_ONE;
        }
    },
    // clears all the neuorns in the layer
    clear: function () {
        var id;
        var neuron;
        for (id in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(id)) {
                neuron = this.listNeurons[id];
                neuron.clear();
            }
        }
    },
    // resets all the neurons in the layer
    reset: function () {
        var id;
        var neuron;
        for (id in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(id)) {
                neuron = this.listNeurons[id];
                neuron.reset();
            }
        }
    },
    // returns all the neurons in the layer (array)
    neurons: function () {
        return this.listNeurons;
    },
    addNeuron: function (neuron) {
        if (neuron instanceof Neuron) {
            this.listNeurons.push(neuron);
            this.size = this.size + 1;
        } else {
            throw new Error('Layer:addNeuron wait a neuron Object.');
        }
    },
    set: function (options) {
        options = options || {};
        var i;
        var neuron;
        for (i in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(i)) {
                neuron = this.listNeurons[i];
                if (options.label) {
                    neuron.label = options.label + '_' + neuron.ID;
                }
                if (options.squash) {
                    neuron.squash = options.squash;
                }
                if (options.bias) {
                    neuron.bias = options.bias;
                }
            }
        }
        return this;
    }
};
// represents a connection from one layer to another, and keeps track of its weight and gain
Layer.connection = function LayerConnection(fromLayer, toLayer, type, weights) {
    this.ID = Layer.connection.uid();
    this.from = fromLayer;
    this.to = toLayer;
    this.selfconnection = toLayer === fromLayer;
    this.type = type;
    this.connections = {};
    this.list = [];
    this.size = 0;
    this.gatedfrom = [];
    var here;
    var there;
    var from;
    var to;
    var connection;
    var neuron;
    if (this.type === undefined) {
        if (fromLayer === toLayer) {
            this.type = Layer.connectionType.ONE_TO_ONE;
        } else {
            this.type = Layer.connectionType.ALL_TO_ALL;
        }
    }
    if (this.type === Layer.connectionType.ALL_TO_ALL || this.type === Layer.connectionType.ALL_TO_ELSE) {
        for (here in this.from.listNeurons) {
            if (this.from.listNeurons.hasOwnProperty(here)) {
                for (there in this.to.listNeurons) {
                    if (this.to.listNeurons.hasOwnProperty(there)) {
                        from = this.from.listNeurons[here];
                        to = this.to.listNeurons[there];
                        if (this.type !== Layer.connectionType.ALL_TO_ELSE || from !== to) {
                            connection = from.project(to, weights);
                            this.connections[connection.ID] = connection;
                            this.size = this.list.push(connection);
                        }
                    }
                }
            }
        }
    } else if (this.type === Layer.connectionType.ONE_TO_ONE) {
        for (neuron in this.from.listNeurons) {
            if (this.from.listNeurons.hasOwnProperty(neuron)) {
                from = this.from.listNeurons[neuron];
                to = this.to.listNeurons[neuron];
                connection = from.project(to, weights);
                this.connections[connection.ID] = connection;
                this.size = this.list.push(connection);
            }
        }
    }
    fromLayer.connectedTo.push(this);
};
// types of connections
Layer.connectionType = {};
Layer.connectionType.ALL_TO_ALL = 'ALL TO ALL';
Layer.connectionType.ONE_TO_ONE = 'ONE TO ONE';
Layer.connectionType.ALL_TO_ELSE = 'ALL TO ELSE';
// types of gates
Layer.gateType = {};
Layer.gateType.INPUT = 'INPUT';
Layer.gateType.OUTPUT = 'OUTPUT';
Layer.gateType.ONE_TO_ONE = 'ONE TO ONE';
(function () {
    var connections = 0;
    Layer.connection.uid = function () {
        connections = connections + 1;
        return connections - 1;
    };
}());
},{"./network":4,"./neuron":5}],4:[function(require,module,exports){
'use strict';
/*global Network*/
/*global escape: true */
/*jslint bitwise: true */
/*jslint evil: true */
// export
if (module) {
    //CHECK THIS GLOBAL VAR
    module.exports = Network;
}
// import
var Neuron = require('./neuron');
var Layer = require('./layer');
/*******************************************************************************************
                                         NETWORK
*******************************************************************************************/
function Network(layers) {
    if (layers !== undefined) {
        this.layers = layers || {
            input: null,
            hidden: {},
            output: null
        };
        this.optimized = null;
    }
}
Network.prototype = {
    // feed-forward activation of all the layers to produce an ouput
    activate: function (input) {
        var layer;
        if (this.optimized === false) {
            this.layers.input.activate(input);
            for (layer in this.layers.hidden) {
                if (this.layers.hidden.hasOwnProperty(layer)) {
                    this.layers.hidden[layer].activate();
                }
            }
            return this.layers.output.activate();
        }
        if (!this.optimized) {
            this.optimize();
        }
        return this.optimized.activate(input);
    },
    // back-propagate the error thru the network
    propagate: function (rate, target) {
        if (this.optimized === false) {
            this.layers.output.propagate(rate, target);
            var reverse = [];
            var layer;
            for (layer in this.layers.hidden) {
                if (this.layers.hidden.hasOwnProperty(layer)) {
                    reverse.push(this.layers.hidden[layer]);
                }
            }
            reverse.reverse();
            for (layer in reverse) {
                if (reverse.hasOwnProperty(layer)) {
                    reverse[layer].propagate(rate);
                }
            }
        } else {
            if (!this.optimized) {
                this.optimize();
            }
            this.optimized.propagate(rate, target);
        }
    },
    // project a connection to another unit (either a network or a layer)
    project: function (unit, type, weights) {
        if (this.optimized) {
            this.optimized.reset();
        }
        if (unit instanceof Network) {
            return this.layers.output.project(unit.layers.input, type, weights);
        }
        if (unit instanceof Layer) {
            return this.layers.output.project(unit, type, weights);
        }
        throw new Error('Invalid argument, you can only project connections to LAYERS and NETWORKS!');
    },
    // let this network gate a connection
    gate: function (connection, type) {
        if (this.optimized) {
            this.optimized.reset();
        }
        this.layers.output.gate(connection, type);
    },
    // clear all elegibility traces and extended elegibility traces (the network forgets its context, but not what was trained)
    clear: function () {
        this.restore();
        var inputLayer = this.layers.input;
        var outputLayer = this.layers.output;
        inputLayer.clear();
        var layer;
        var hiddenLayer;
        for (layer in this.layers.hidden) {
            if (this.layers.hidden.hasOwnProperty(layer)) {
                hiddenLayer = this.layers.hidden[layer];
                hiddenLayer.clear();
            }
        }
        outputLayer.clear();
        if (this.optimized) {
            this.optimized.reset();
        }
    },
    // reset all weights and clear all traces (ends up like a new network)
    reset: function () {
        this.restore();
        var inputLayer = this.layers.input;
        var outputLayer = this.layers.output;
        inputLayer.reset();
        var layer;
        var hiddenLayer;
        for (layer in this.layers.hidden) {
            if (this.layers.hidden.hasOwnProperty(layer)) {
                hiddenLayer = this.layers.hidden[layer];
                hiddenLayer.reset();
            }
        }
        outputLayer.reset();
        if (this.optimized) {
            this.optimized.reset();
        }
    },
    // hardcodes the behaviour of the whole network into a single optimized function
    optimize: function () {
        var that = this;
        var optimized = {};
        var neurons = this.neurons();
        var i;
        var neuron;
        var layer;
        for (i in neurons) {
            if (neurons.hasOwnProperty(i)) {
                neuron = neurons[i].neuron;
                layer = neurons[i].layer;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                optimized = neuron.optimize(optimized, layer);
            }
        }
        for (i in optimized.propagation_sentences) {
            if (optimized.propagation_sentences.hasOwnProperty(i)) {
                optimized.propagation_sentences[i].reverse();
            }
        }
        optimized.propagation_sentences.reverse();
        var hardcode = '';
        hardcode += 'var F = Float64Array ? new Float64Array(' + optimized.memory + ') : []; ';
        for (i in optimized.variables) {
            if (optimized.variables.hasOwnProperty(i)) {
                hardcode += 'F[' + optimized.variables[i].id + '] = ' + (optimized.variables[i].value || 0) + '; ';
            }
        }
        hardcode += 'var activate = function(input){\n';
        for (i in optimized.inputs) {
            if (optimized.inputs.hasOwnProperty(i)) {
                hardcode += 'F[' + optimized.inputs[i] + '] = input[' + i + ']; ';
            }
        }
        var currentLayer;
        var currentNeuron;
        for (currentLayer in optimized.activation_sentences) {
            if (optimized.activation_sentences.hasOwnProperty(currentLayer)) {
                if (optimized.activation_sentences[currentLayer].length > 0) {
                    for (currentNeuron in optimized.activation_sentences[currentLayer]) {
                        if (optimized.activation_sentences[currentLayer].hasOwnProperty(currentNeuron)) {
                            hardcode += optimized.activation_sentences[currentLayer][currentNeuron].join(' ');
                            hardcode += optimized.trace_sentences[currentLayer][currentNeuron].join(' ');
                        }
                    }
                }
            }
        }
        hardcode += ' var output = []; ';
        for (i in optimized.outputs) {
            if (optimized.outputs.hasOwnProperty(i)) {
                hardcode += 'output[' + i + '] = F[' + optimized.outputs[i] + ']; ';
            }
        }
        hardcode += 'return output; }; ';
        hardcode += 'var propagate = function(rate, target){\n';
        hardcode += 'F[' + optimized.variables.rate.id + '] = rate; ';
        for (i in optimized.targets) {
            if (optimized.targets.hasOwnProperty(i)) {
                hardcode += 'F[' + optimized.targets[i] + '] = target[' + i + ']; ';
            }
        }
        for (currentLayer in optimized.propagation_sentences) {
            if (optimized.propagation_sentences.hasOwnProperty(currentLayer)) {
                for (currentNeuron in optimized.propagation_sentences[currentLayer]) {
                    if (optimized.propagation_sentences[currentLayer].hasOwnProperty(currentNeuron)) {
                        hardcode += optimized.propagation_sentences[currentLayer][currentNeuron].join(' ') + ' ';
                    }
                }
            }
        }
        hardcode += ' };\n';
        hardcode += 'var ownership = function(memoryBuffer){\nF = memoryBuffer;\nthis.memory = F;\n};\n';
        hardcode += 'return {\nmemory: F,\nactivate: activate,\npropagate: propagate,\nownership: ownership\n};';
        hardcode = hardcode.split(';').join(';\n');
        var constructor = new Function(hardcode);
        var network = constructor();
        network.data = {
            variables: optimized.variables,
            activate: optimized.activation_sentences,
            propagate: optimized.propagation_sentences,
            trace: optimized.trace_sentences,
            inputs: optimized.inputs,
            outputs: optimized.outputs,
            check_activation: this.activate,
            check_propagation: this.propagate
        };
        network.reset = function () {
            if (that.optimized) {
                that.optimized = null;
                that.activate = network.data.check_activation;
                that.propagate = network.data.check_propagation;
            }
        };
        this.optimized = network;
        this.activate = network.activate;
        this.propagate = network.propagate;
    },
    // restores all the values from the optimized network the their respective objects in order to manipulate the network
    restore: function () {
        if (!this.optimized) {
            return;
        }
        var optimized = this.optimized;
        var getValue = function () {
            var args = Array.prototype.slice.call(arguments);
            var unit = args.shift();
            var prop = args.pop();
            var id = prop + '_';
            var property;
            for (property in args) {
                if (args.hasOwnProperty(property)) {
                    id += args[property] + '_';
                }
            }
            id += unit.ID;
            var memory = optimized.memory;
            var variables = optimized.data.variables;
            if (variables.hasOwnProperty(id)) {
                return memory[variables[id].id];
            }
            return 0;
        };
        var list = this.neurons();
        var i;
        var neuron;
        var input;
        var gated;
        var j;
        var connection;
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                neuron.state = getValue(neuron, 'state');
                neuron.old = getValue(neuron, 'old');
                neuron.activation = getValue(neuron, 'activation');
                neuron.bias = getValue(neuron, 'bias');
                for (input in neuron.trace.elegibility) {
                    if (neuron.trace.elegibility.hasOwnProperty(input)) {
                        neuron.trace.elegibility[input] = getValue(neuron, 'trace', 'elegibility', input);
                    }
                }
                for (gated in neuron.trace.extended) {
                    if (neuron.trace.extended.hasOwnProperty(gated)) {
                        for (input in neuron.trace.extended[gated]) {
                            if (neuron.trace.extended[gated].hasOwnProperty(input)) {
                                neuron.trace.extended[gated][input] = getValue(neuron, 'trace', 'extended', gated, input);
                            }
                        }
                    }
                }
            }
        }
        // get connections
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                for (j in neuron.connections.projected) {
                    if (neuron.connections.projected.hasOwnProperty(j)) {
                        connection = neuron.connections.projected[j];
                        connection.weight = getValue(connection, 'weight');
                        connection.gain = getValue(connection, 'gain');
                    }
                }
            }
        }
    },
    // returns all the neurons in the network
    neurons: function () {
        var neurons = [];
        var inputLayer = this.layers.input.neurons();
        var outputLayer = this.layers.output.neurons();
        var neuron;
        var layer;
        var hiddenLayer;
        for (neuron in inputLayer) {
            if (inputLayer.hasOwnProperty(neuron)) {
                neurons.push({
                    neuron: inputLayer[neuron],
                    layer: 'input'
                });
            }
        }
        for (layer in this.layers.hidden) {
            if (this.layers.hidden.hasOwnProperty(layer)) {
                hiddenLayer = this.layers.hidden[layer].neurons();
                for (neuron in hiddenLayer) {
                    if (hiddenLayer.hasOwnProperty(neuron)) {
                        neurons.push({
                            neuron: hiddenLayer[neuron],
                            layer: layer
                        });
                    }
                }
            }
        }
        for (neuron in outputLayer) {
            if (outputLayer.hasOwnProperty(neuron)) {
                neurons.push({
                    neuron: outputLayer[neuron],
                    layer: 'output'
                });
            }
        }
        return neurons;
    },
    // returns number of inputs of the network
    inputs: function () {
        return this.layers.input.size;
    },
    // returns number of outputs of hte network
    outputs: function () {
        return this.layers.output.size;
    },
    // sets the layers of the network
    set: function (layers) {
        this.layers = layers;
        if (this.optimized) {
            this.optimized.reset();
        }
    },
    setOptimize: function (bool) {
        this.restore();
        if (this.optimized) {
            this.optimized.reset();
        }
        this.optimized = bool ? null : false;
    },
    // returns a json that represents all the neurons and connections of the network
    toJSON: function () {
        this.restore();
        var list = this.neurons();
        var neurons = [];
        var connections = [];
        // link id's to positions in the array
        var ids = {};
        var i;
        var neuron;
        var copy;
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                ids[neuron.ID] = i;
                copy = {
                    trace: {
                        elegibility: {},
                        extended: {}
                    },
                    state: neuron.state,
                    old: neuron.old,
                    activation: neuron.activation,
                    bias: neuron.bias,
                    layer: list[i].layer
                };
                copy.squash = neuron.squash === Neuron.squash.LOGISTIC ? 'LOGISTIC' : neuron.squash === Neuron.squash.TANH ? 'TANH' : neuron.squash === Neuron.squash.IDENTITY ? 'IDENTITY' : neuron.squash === Neuron.squash.HLIM ? 'HLIM' : null;
                neurons.push(copy);
            }
        }
        // get connections
        var j;
        var connection;
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                for (j in neuron.connections.projected) {
                    if (neuron.connections.projected.hasOwnProperty(j)) {
                        connection = neuron.connections.projected[j];
                        connections.push({
                            from: ids[connection.from.ID],
                            to: ids[connection.to.ID],
                            weight: connection.weight,
                            gater: connection.gater ? ids[connection.gater.ID] : null
                        });
                    }
                }
                if (neuron.selfconnected()) {
                    connections.push({
                        from: ids[neuron.ID],
                        to: ids[neuron.ID],
                        weight: neuron.selfconnection.weight,
                        gater: neuron.selfconnection.gater ? ids[neuron.selfconnection.gater.ID] : null
                    });
                }
            }
        }
        return {
            neurons: neurons,
            connections: connections
        };
    },
    // export the topology into dot language which can be visualized as graphs using dot
    // example: ... console.log(net.toDotLang());$ node example.js > example.dot;$ dot example.dot -Tpng > out.png
    toDot: function (edgeConnection) {
        if (!edgeConnection || edgeConnection === undefined) {
            edgeConnection = false;
        }
        var code = 'digraph nn {\n    rankdir = BT\n';
        var layers = [this.layers.input].concat(this.layers.hidden, this.layers.output);
        var layer;
        var to;
        var connection;
        var layerTo;
        var size;
        var layerID;
        var layerToID;
        var fakeNode;
        var from;
        var layerfrom;
        var layerfromID;
        for (layer in layers) {
            if (layers.hasOwnProperty(layer)) {
                for (to in layers[layer].connectedTo) {
                    if (layers[layer].connectedTo.hasOwnProperty(to)) {
                        // projections
                        connection = layers[layer].connectedTo[to];
                        layerTo = connection.to;
                        size = connection.size;
                        layerID = layers.indexOf(layers[layer]);
                        layerToID = layers.indexOf(layerTo);
                        /* http://stackoverflow.com/questions/26845540/connect-edges-with-graph-dot
                         * DOT does not support edge-to-edge connections
                         * This workaround produces somewhat weird graphs ...
                         */
                        if (edgeConnection) {
                            if (connection.gatedfrom.length) {
                                fakeNode = 'fake' + layerID + '_' + layerToID;
                                code += '    ' + fakeNode + ' [label = "", shape = point, width = 0.01, height = 0.01]\n';
                                code += '    ' + layerID + ' -> ' + fakeNode + ' [label = ' + size + ', arrowhead = none]\n';
                                code += '    ' + fakeNode + ' -> ' + layerToID + '\n';
                            } else {
                                code += '    ' + layerID + ' -> ' + layerToID + ' [label = ' + size + ']\n';
                            }
                            for (from in connection.gatedfrom) {
                                if (connection.gatedfrom.hasOwnProperty(from)) {
                                    // gatings
                                    layerfrom = connection.gatedfrom[from].layer;
                                    layerfromID = layers.indexOf(layerfrom);
                                    code += '    ' + layerfromID + ' -> ' + fakeNode + ' [color = blue]\n';
                                }
                            }
                        } else {
                            code += '    ' + layerID + ' -> ' + layerToID + ' [label = ' + size + ']\n';
                            for (from in connection.gatedfrom) {
                                if (connection.gatedfrom.hasOwnProperty(from)) {
                                    // gatings
                                    layerfrom = connection.gatedfrom[from].layer;
                                    layerfromID = layers.indexOf(layerfrom);
                                    code += '    ' + layerfromID + ' -> ' + layerToID + ' [color = blue]\n';
                                }
                            }
                        }
                    }
                }
            }
        }
        code += '}\n';
        return {
            code: code,
            link: 'https://chart.googleapis.com/chart?chl=' + escape(code.replace('/ /g', '+')) + '&cht=gv'
        };
    },
    // returns a function that works as the activation of the network and can be used without depending on the library
    standalone: function () {
        if (!this.optimized) {
            this.optimize();
        }
        var data = this.optimized.data;
        // build activation function
        var activation = 'function (input) {\n';
        // build inputs
        var i;
        var neuron;
        var sentence;
        for (i in data.inputs) {
            if (data.inputs.hasOwnProperty(i)) {
                activation += 'F[' + data.inputs[i] + '] = input[' + i + '];\n';
            }
        }
        // build network activation
        for (neuron in data.activate) {
            if (data.activate.hasOwnProperty(neuron)) {
                // shouldn't this be layer?
                for (sentence in data.activate[neuron]) {
                    if (data.activate[neuron].hasOwnProperty(sentence)) {
                        activation += data.activate[neuron][sentence].join('') + '\n';
                    }
                }
            }
        }
        // build outputs
        activation += 'var output = [];\n';
        for (i in data.outputs) {
            if (data.outputs.hasOwnProperty(i)) {
                activation += 'output[' + i + '] = F[' + data.outputs[i] + '];\n';
            }
        }
        activation += 'return output;\n}';
        // reference all the positions in memory
        var memory = activation.match(/F\[(\d+)\]/g);
        var dimension = 0;
        var ids = {};
        var address;
        var tmp;
        for (address in memory) {
            if (memory.hasOwnProperty(address)) {
                tmp = memory[address].match(/\d+/)[0];
                if (!ids.hasOwnProperty(tmp)) {
                    ids[tmp] = dimension;
                    dimension = dimension + 1;
                }
            }
        }
        var hardcode = 'F = {\n';
        for (i in ids) {
            if (ids.hasOwnProperty(i)) {
                hardcode += ids[i] + ': ' + this.optimized.memory[i] + ',\n';
            }
        }
        hardcode = hardcode.substring(0, hardcode.length - 2) + '\n};\n';
        hardcode = 'var run = ' + activation.replace(/F\[(\d+)\]/g, function (index) {
            return 'F[' + ids[index.match(/\d+/)[0]] + ']';
        }).replace('{\n', '{\n' + hardcode) + ';\n';
        hardcode += 'return run';
        // return standalone function
        return new Function(hardcode)();
    },
    worker: function () {
        /*global Blob*/
        /*global window*/
        /*global Worker*/
        if (!this.optimized) {
            this.optimize();
        }
        var hardcode = 'var inputs = ' + this.optimized.data.inputs.length + ';\n';
        hardcode += 'var outputs = ' + this.optimized.data.outputs.length + ';\n';
        hardcode += 'var F = null;\n';
        hardcode += 'var activate = ' + this.optimized.activate.toString() + ';\n';
        hardcode += 'var propagate = ' + this.optimized.propagate.toString() + ';\n';
        hardcode += 'onmessage = function(e){\n';
        hardcode += 'F = e.data.memoryBuffer;\n';
        hardcode += 'if (e.data.action == \'activate\'){\n';
        hardcode += 'if (e.data.input.length == inputs){\n';
        hardcode += 'postMessage( { action: \'activate\', output: activate(e.data.input), memoryBuffer: F }, [F.buffer]);\n';
        hardcode += '}\n}\nelse if (e.data.action == \'propagate\'){\n';
        hardcode += 'propagate(e.data.rate, e.data.target);\n';
        hardcode += 'postMessage({ action: \'propagate\', memoryBuffer: F }, [F.buffer]);\n';
        hardcode += '}\n}\n';
        var blob = new Blob([hardcode]);
        var blobURL = window.URL.createObjectURL(blob);
        return new Worker(blobURL);
    },
    // returns a copy of the network
    clone: function () {
        return Network.fromJSON(this.toJSON());
    }
};
// rebuild a network that has been stored in a json using the method toJSON()
Network.fromJSON = function (json) {
    var neurons = [];
    var layers = {
        input: new Layer(),
        hidden: [],
        output: new Layer()
    };
    var neuron;
    var config;
    var i;
    for (i in json.neurons) {
        if (json.neurons.hasOwnProperty(i)) {
            config = json.neurons[i];
            neuron = new Neuron();
            neuron.trace.elegibility = {};
            neuron.trace.extended = {};
            neuron.state = config.state;
            neuron.old = config.old;
            neuron.activation = config.activation;
            neuron.bias = config.bias;
            neuron.squash = Neuron.squash.hasOwnProperty(config.squash) ? Neuron.squash[config.squash] : Neuron.squash.LOGISTIC;
            neurons.push(neuron);
            if (config.layer === 'input') {
                layers.input.addNeuron(neuron);
            } else if (config.layer === 'output') {
                layers.output.addNeuron(neuron);
            } else {
                if (layers.hidden[config.layer] === undefined) {
                    layers.hidden[config.layer] = new Layer();
                }
                layers.hidden[config.layer].addNeuron(neuron);
            }
        }
    }
    var from;
    var to;
    var weight;
    var gater;
    var connection;
    for (i in json.connections) {
        if (json.connections.hasOwnProperty(i)) {
            config = json.connections[i];
            from = neurons[config.from];
            to = neurons[config.to];
            weight = config.weight;
            gater = neurons[config.gater];
            connection = from.project(to, weight);
            if (gater) {
                gater.gate(connection);
            }
        }
    }
    return new Network(layers);
};
},{"./layer":3,"./neuron":5}],5:[function(require,module,exports){
'use strict';
/*global Neuron*/
// export
if (module) {
    module.exports = Neuron;
}
/******************************************************************************************
                                         NEURON
*******************************************************************************************/
function Neuron() {
    this.ID = Neuron.uid();
    this.label = null;
    this.connections = {
        inputs: {},
        projected: {},
        gated: {}
    };
    this.error = {
        responsibility: 0,
        projected: 0,
        gated: 0
    };
    this.trace = {
        elegibility: {},
        extended: {},
        influences: {}
    };
    this.state = 0;
    this.old = 0;
    this.activation = 0;
    this.selfconnection = new Neuron.connection(this, this, 0);
    // weight = 0 -> not connected
    this.squash = Neuron.squash.LOGISTIC;
    this.neighboors = {};
    this.bias = Math.random() * 0.2 - 0.1;
}
Neuron.prototype = {
    // activate the neuron
    activate: function (input) {
        // activation from enviroment (for input neurons)
        if (input !== undefined) {
            this.activation = input;
            this.derivative = 0;
            this.bias = 0;
            return this.activation;
        }
        // old state
        this.old = this.state;
        // eq. 15
        this.state = this.selfconnection.gain * this.selfconnection.weight * this.state + this.bias;
        var i;
        for (i in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(i)) {
                input = this.connections.inputs[i];
                if (input.gater) {
                    this.state += input.from.activation * input.weight * input.gain;
                }
            }
        }
        for (i in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(i)) {
                input = this.connections.inputs[i];
                if (!input.gater) {
                    this.state += input.from.activation * input.weight;
                }
            }
        }
        // eq. 16
        this.activation = this.squash(this.state);
        // f'(s)
        this.derivative = this.squash(this.state, true);
        // update traces
        var influences = [];
        var id;
        var xtrace;
        var neuron;
        var influence;
        var incoming;
        for (id in this.trace.extended) {
            if (this.trace.extended.hasOwnProperty(id)) {
                // extended elegibility trace
                xtrace = this.trace.extended[id];
                neuron = this.neighboors[id];
                // if gated neuron's selfconnection is gated by this unit, the influence keeps track of the neuron's old state
                influence = neuron.selfconnection.gater === this ? neuron.old : 0;
                // index runs over all the incoming connections to the gated neuron that are gated by this unit
                for (incoming in this.trace.influences[neuron.ID]) {
                    if (this.trace.influences[neuron.ID].hasOwnProperty(incoming)) {
                        // captures the effect that has an input connection to this unit, on a neuron that is gated by this unit
                        influence += this.trace.influences[neuron.ID][incoming].weight * this.trace.influences[neuron.ID][incoming].from.activation;
                    }
                }
                influences[neuron.ID] = influence;
            }
        }
        for (i in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(i)) {
                input = this.connections.inputs[i];
                // elegibility trace - Eq. 17
                this.trace.elegibility[input.ID] = this.selfconnection.gain * this.selfconnection.weight * this.trace.elegibility[input.ID] + input.gain * input.from.activation;
                for (id in this.trace.extended) {
                    if (this.trace.extended.hasOwnProperty(id)) {
                        // extended elegibility trace
                        xtrace = this.trace.extended[id];
                        neuron = this.neighboors[id];
                        influence = influences[neuron.ID];
                        // eq. 18
                        xtrace[input.ID] = neuron.selfconnection.gain * neuron.selfconnection.weight * xtrace[input.ID] + this.derivative * this.trace.elegibility[input.ID] * influence;
                    }
                }
            }
        }
        var connection;
        //  update gated connection's gains
        for (connection in this.connections.gated) {
            if (this.connections.gated.hasOwnProperty(connection)) {
                this.connections.gated[connection].gain = this.activation;
            }
        }
        return this.activation;
    },
    // back-propagate the error
    propagate: function (rate, target) {
        // error accumulator
        var error = 0;
        // whether or not this neuron is in the output layer
        var isOutput = target !== undefined;
        var id;
        var input;
        var neuron;
        // output neurons get their error from the enviroment
        if (isOutput) {
            this.error.responsibility = this.error.projected = target - this.activation; // Eq. 10
        } else {
            var connection;
            // the rest of the neuron compute their error responsibilities by backpropagation
            // error responsibilities from all the connections projected from this neuron
            for (id in this.connections.projected) {
                if (this.connections.projected.hasOwnProperty(id)) {
                    connection = this.connections.projected[id];
                    neuron = connection.to;
                    // Eq. 21
                    error += neuron.error.responsibility * connection.gain * connection.weight;
                }
            }
            // projected error responsibility
            this.error.projected = this.derivative * error;
            error = 0;
            var influence;
            // error responsibilities from all the connections gated by this neuron
            for (id in this.trace.extended) {
                if (this.trace.extended.hasOwnProperty(id)) {
                    neuron = this.neighboors[id];
                    // gated neuron
                    influence = neuron.selfconnection.gater === this ? neuron.old : 0;
                    // if gated neuron's selfconnection is gated by this neuron
                    // index runs over all the connections to the gated neuron that are gated by this neuron
                    for (input in this.trace.influences[id]) {
                        if (this.trace.influences[id].hasOwnProperty(input)) {
                            // captures the effect that the input connection of this neuron have, on a neuron which its input/s is/are gated by this neuron
                            influence += this.trace.influences[id][input].weight * this.trace.influences[neuron.ID][input].from.activation;
                        }
                    }
                    // eq. 22
                    error += neuron.error.responsibility * influence;
                }
            }
            // gated error responsibility
            this.error.gated = this.derivative * error;
            // error responsibility - Eq. 23
            this.error.responsibility = this.error.projected + this.error.gated;
        }
        // learning rate
        rate = rate || 0.1;
        var gradient;
        // adjust all the neuron's incoming connections
        for (id in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(id)) {
                input = this.connections.inputs[id];
                // Eq. 24
                gradient = this.error.projected * this.trace.elegibility[input.ID];
                for (id in this.trace.extended) {
                    if (this.trace.extended.hasOwnProperty(id)) {
                        neuron = this.neighboors[id];
                        gradient += neuron.error.responsibility * this.trace.extended[neuron.ID][input.ID];
                    }
                }
                input.weight += rate * gradient; // adjust weights - aka learn
            }
        }
        // adjust bias
        this.bias += rate * this.error.responsibility;
    },
    project: function (neuron, weight) {
        // self-connection
        if (neuron === this) {
            this.selfconnection.weight = 1;
            return this.selfconnection;
        }
        // check if connection already exists
        var connected = this.connected(neuron);
        if (connected && connected.type === 'projected') {
            // update connection
            if (weight !== undefined) {
                connected.connection.weight = weight;
            }
            // return existing connection
            return connected.connection;
        }
        // create a new connection
        var connection = new Neuron.connection(this, neuron, weight);
        // reference all the connections and traces
        this.connections.projected[connection.ID] = connection;
        this.neighboors[neuron.ID] = neuron;
        neuron.connections.inputs[connection.ID] = connection;
        neuron.trace.elegibility[connection.ID] = 0;
        var id;
        var trace;
        for (id in neuron.trace.extended) {
            if (neuron.trace.extended.hasOwnProperty(id)) {
                trace = neuron.trace.extended[id];
                trace[connection.ID] = 0;
            }
        }
        return connection;
    },
    gate: function (connection) {
        // add connection to gated list
        this.connections.gated[connection.ID] = connection;
        var neuron = connection.to;
        var xtrace;
        if (!this.trace.extended.hasOwnProperty(neuron.ID)) {
            // extended trace
            this.neighboors[neuron.ID] = neuron;
            xtrace = this.trace.extended[neuron.ID] = {};
            var id;
            var input;
            for (id in this.connections.inputs) {
                if (this.connections.inputs.hasOwnProperty(id)) {
                    input = this.connections.inputs[id];
                    xtrace[input.ID] = 0;
                }
            }
        }
        // keep track
        if (this.trace.influences.hasOwnProperty(neuron.ID)) {
            this.trace.influences[neuron.ID].push(connection);
        } else {
            this.trace.influences[neuron.ID] = [connection];
        }
        // set gater
        connection.gater = this;
    },
    // returns true or false whether the neuron is self-connected or not
    selfconnected: function () {
        return this.selfconnection.weight !== 0;
    },
    // returns true or false whether the neuron is connected to another neuron (parameter)
    connected: function (neuron) {
        var result = {
            type: null,
            connection: false
        };
        if (this === neuron) {
            if (this.selfconnected()) {
                result.type = 'selfconnection';
                result.connection = this.selfconnection;
                return result;
            }
            return false;
        }
        var type;
        var connection;
        for (type in this.connections) {
            if (this.connections.hasOwnProperty(type)) {
                for (connection in this.connections[type]) {
                    if (this.connections[type].hasOwnProperty(connection)) {
                        connection = this.connections[type][connection];
                        if (connection.to === neuron) {
                            result.type = type;
                            result.connection = connection;
                            return result;
                        }
                        if (connection.from === neuron) {
                            result.type = type;
                            result.connection = connection;
                            return result;
                        }
                    }
                }
            }
        }
        return false;
    },
    // clears all the traces (the neuron forgets it's context, but the connections remain intact)
    clear: function () {
        var trace;
        var extended;
        for (trace in this.trace.elegibility) {
            if (this.trace.elegibility.hasOwnProperty(trace)) {
                this.trace.elegibility[trace] = 0;
            }
        }
        for (trace in this.trace.extended) {
            if (this.trace.extended.hasOwnProperty(trace)) {
                for (extended in this.trace.extended[trace]) {
                    if (this.trace.extended[trace].hasOwnProperty(extended)) {
                        this.trace.extended[trace][extended] = 0;
                    }
                }
            }
        }
        this.error.responsibility = this.error.projected = this.error.gated = 0;
    },
    // all the connections are randomized and the traces are cleared
    reset: function () {
        this.clear();
        var type;
        var connection;
        for (type in this.connections) {
            if (this.connections.hasOwnProperty(type)) {
                for (connection in this.connections[type]) {
                    if (this.connections[type].hasOwnProperty(connection)) {
                        this.connections[type][connection].weight = Math.random() * 0.2 - 0.1;
                    }
                }
            }
        }
        this.bias = Math.random() * 0.2 - 0.1;
        this.old = this.state = this.activation = 0;
    },
    // hardcodes the behaviour of the neuron into an optimized function
    optimize: function (optimized, layer) {
        /*jslint nomen: true*/
        optimized = optimized || {};
        var store_activation = [];
        var store_trace = [];
        var store_propagation = [];
        var varID = optimized.memory || 0;
        var neurons = optimized.neurons || 1;
        var inputs = optimized.inputs || [];
        var input;
        var neuron_responsibility;
        var trace;
        var derivative;
        var gradient;
        var xtrace;
        var influence;
        var neuron_old;
        var bias;
        var initialized;
        var incoming;
        var incoming_weight;
        var incoming_activation;
        var connection_gain;
        var connection;
        var neuron;
        var neuron_activation;
        var connection_weight;
        var input_weight;
        var targets = optimized.targets || [];
        var outputs = optimized.outputs || [];
        var variables = optimized.variables || {};
        var activation_sentences = optimized.activation_sentences || [];
        var trace_sentences = optimized.trace_sentences || [];
        var propagation_sentences = optimized.propagation_sentences || [];
        var layers = optimized.layers || {
            __count: 0,
            __neuron: 0
        };
        // allocate sentences
        var allocate = function (store) {
            var allocated = layers.hasOwnProperty(layer) && store[layers.__count];
            if (!allocated) {
                layers.__count = store.push([]) - 1;
                layers[layer] = layers.__count;
            }
        };
        allocate(activation_sentences);
        allocate(trace_sentences);
        allocate(propagation_sentences);
        var currentLayer = layers.__count;
        // get/reserve space in memory by creating a unique ID for a variablel
        var getVar = function () {
            var args = Array.prototype.slice.call(arguments);
            var id;
            if (args.length === 1) {
                if (args[0] === 'target') {
                    id = 'target_' + targets.length;
                    targets.push(varID);
                } else {
                    id = args[0];
                }
                if (variables.hasOwnProperty(id)) {
                    return variables[id];
                }
                varID = varID + 1;
                variables[id] = {
                    value: 0,
                    id: varID - 1
                };
                return variables[id];
            }
            var extended = args.length > 2;
            var value;
            if (extended) {
                value = args.pop();
            }
            var unit = args.shift();
            var prop = args.pop();
            if (!extended) {
                value = unit[prop];
            }
            id = prop + '_';
            var property;
            for (property in args) {
                if (args.hasOwnProperty(property)) {
                    id += args[property] + '_';
                }
            }
            id += unit.ID;
            if (variables.hasOwnProperty(id)) {
                return variables[id];
            }
            varID = varID + 1;
            variables[id] = {
                value: value,
                id: varID - 1
            };
            return variables[id];
        };
        // build sentence
        var buildSentence = function () {
            var args = Array.prototype.slice.call(arguments);
            var store = args.pop();
            var sentence = '';
            var i;
            for (i in args) {
                if (args.hasOwnProperty(i)) {
                    if (typeof args[i] === 'string') {
                        sentence += args[i];
                    } else {
                        sentence += 'F[' + args[i].id + ']';
                    }
                }
            }
            store.push(sentence + ';');
        };
        // helper to check if an object is empty
        var isEmpty = function (obj) {
            var prop;
            for (prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }
            return true;
        };
        // characteristics of the neuron
        var noProjections = isEmpty(this.connections.projected);
        var noGates = isEmpty(this.connections.gated);
        var isInput = layer === 'input' ? true : isEmpty(this.connections.inputs);
        var isOutput = layer === 'output' ? true : noProjections && noGates;
        // optimize neuron's behaviour
        var rate = getVar('rate');
        var activation = getVar(this, 'activation');
        var id;
        if (isInput) {
            inputs.push(activation.id);
        } else {
            activation_sentences[currentLayer].push(store_activation);
            trace_sentences[currentLayer].push(store_trace);
            propagation_sentences[currentLayer].push(store_propagation);
            var old = getVar(this, 'old');
            var state = getVar(this, 'state');
            bias = getVar(this, 'bias');
            var self_gain;
            if (this.selfconnection.gater) {
                self_gain = getVar(this.selfconnection, 'gain');
            }
            var self_weight;
            if (this.selfconnected()) {
                self_weight = getVar(this.selfconnection, 'weight');
            }
            buildSentence(old, ' = ', state, store_activation);
            if (this.selfconnected()) {
                if (this.selfconnection.gater) {
                    buildSentence(state, ' = ', self_gain, ' * ', self_weight, ' * ', state, ' + ', bias, store_activation);
                } else {
                    buildSentence(state, ' = ', self_weight, ' * ', state, ' + ', bias, store_activation);
                }
            } else {
                buildSentence(state, ' = ', bias, store_activation);
            }
            var i;
            var input_activation;
            var input_gain;
            for (i in this.connections.inputs) {
                if (this.connections.inputs.hasOwnProperty(i)) {
                    input = this.connections.inputs[i];
                    input_activation = getVar(input.from, 'activation');
                    input_weight = getVar(input, 'weight');
                    if (input.gater) {
                        input_gain = getVar(input, 'gain');
                        buildSentence(state, ' += ', input_activation, ' * ', input_weight, ' * ', input_gain, store_activation);
                    } else {
                        buildSentence(state, ' += ', input_activation, ' * ', input_weight, store_activation);
                    }
                }
            }
            derivative = getVar(this, 'derivative');
            switch (this.squash) {
            case Neuron.squash.LOGISTIC:
                buildSentence(activation, ' = (1 / (1 + Math.exp(-', state, ')))', store_activation);
                buildSentence(derivative, ' = ', activation, ' * (1 - ', activation, ')', store_activation);
                break;
            case Neuron.squash.TANH:
                var eP = getVar('aux');
                var eN = getVar('aux_2');
                buildSentence(eP, ' = Math.exp(', state, ')', store_activation);
                buildSentence(eN, ' = 1 / ', eP, store_activation);
                buildSentence(activation, ' = (', eP, ' - ', eN, ') / (', eP, ' + ', eN, ')', store_activation);
                buildSentence(derivative, ' = 1 - (', activation, ' * ', activation, ')', store_activation);
                break;
            case Neuron.squash.IDENTITY:
                buildSentence(activation, ' = ', state, store_activation);
                buildSentence(derivative, ' = 1', store_activation);
                break;
            case Neuron.squash.HLIM:
                buildSentence(activation, ' = +(', state, ' > 0)', store_activation);
                buildSentence(derivative, ' = 1', store_activation);
                break;
            case Neuron.squash.RELU:
                buildSentence(activation, ' = ', state, ' > 0 ? ', state, ' : 0', store_activation);
                buildSentence(derivative, ' = ', state, ' > 0 ? 1 : 0', store_activation);
                break;
            }
            for (id in this.trace.extended) {
                if (this.trace.extended.hasOwnProperty(id)) {
                    // calculate extended elegibility traces in advance
                    xtrace = this.trace.extended[id];
                    neuron = this.neighboors[id];
                    influence = getVar('influences[' + neuron.ID + ']');
                    neuron_old = getVar(neuron, 'old');
                    initialized = false;
                    if (neuron.selfconnection.gater === this) {
                        buildSentence(influence, ' = ', neuron_old, store_trace);
                        initialized = true;
                    }
                    for (incoming in this.trace.influences[neuron.ID]) {
                        if (this.trace.influences[neuron.ID].hasOwnProperty(incoming)) {
                            incoming_weight = getVar(this.trace.influences[neuron.ID][incoming], 'weight');
                            incoming_activation = getVar(this.trace.influences[neuron.ID][incoming].from, 'activation');
                            if (initialized) {
                                buildSentence(influence, ' += ', incoming_weight, ' * ', incoming_activation, store_trace);
                            } else {
                                buildSentence(influence, ' = ', incoming_weight, ' * ', incoming_activation, store_trace);
                                initialized = true;
                            }
                        }
                    }
                }
            }
            var neuron_self_weight;
            var neuron_self_gain;
            for (i in this.connections.inputs) {
                if (this.connections.inputs.hasOwnProperty(i)) {
                    input = this.connections.inputs[i];
                    if (input.gater) {
                        input_gain = getVar(input, 'gain');
                    }
                    input_activation = getVar(input.from, 'activation');
                    trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                    if (this.selfconnected()) {
                        if (this.selfconnection.gater) {
                            if (input.gater) {
                                buildSentence(trace, ' = ', self_gain, ' * ', self_weight, ' * ', trace, ' + ', input_gain, ' * ', input_activation, store_trace);
                            } else {
                                buildSentence(trace, ' = ', self_gain, ' * ', self_weight, ' * ', trace, ' + ', input_activation, store_trace);
                            }
                        } else {
                            if (input.gater) {
                                buildSentence(trace, ' = ', self_weight, ' * ', trace, ' + ', input_gain, ' * ', input_activation, store_trace);
                            } else {
                                buildSentence(trace, ' = ', self_weight, ' * ', trace, ' + ', input_activation, store_trace);
                            }
                        }
                    } else {
                        if (input.gater) {
                            buildSentence(trace, ' = ', input_gain, ' * ', input_activation, store_trace);
                        } else {
                            buildSentence(trace, ' = ', input_activation, store_trace);
                        }
                    }
                    for (id in this.trace.extended) {
                        if (this.trace.extended.hasOwnProperty(id)) {
                            // extended elegibility trace
                            xtrace = this.trace.extended[id];
                            neuron = this.neighboors[id];
                            influence = getVar('influences[' + neuron.ID + ']');
                            neuron_old = getVar(neuron, 'old');
                            trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                            xtrace = getVar(this, 'trace', 'extended', neuron.ID, input.ID, this.trace.extended[neuron.ID][input.ID]);
                            if (neuron.selfconnected()) {
                                neuron_self_weight = getVar(neuron.selfconnection, 'weight');
                            }
                            if (neuron.selfconnection.gater) {
                                neuron_self_gain = getVar(neuron.selfconnection, 'gain');
                            }
                            if (neuron.selfconnected()) {
                                if (neuron.selfconnection.gater) {
                                    buildSentence(xtrace, ' = ', neuron_self_gain, ' * ', neuron_self_weight, ' * ', xtrace, ' + ', derivative, ' * ', trace, ' * ', influence, store_trace);
                                } else {
                                    buildSentence(xtrace, ' = ', neuron_self_weight, ' * ', xtrace, ' + ', derivative, ' * ', trace, ' * ', influence, store_trace);
                                }
                            } else {
                                buildSentence(xtrace, ' = ', derivative, ' * ', trace, ' * ', influence, store_trace);
                            }
                        }
                    }
                }
            }
            var gated_gain;
            for (connection in this.connections.gated) {
                if (this.connections.gated.hasOwnProperty(connection)) {
                    gated_gain = getVar(this.connections.gated[connection], 'gain');
                    buildSentence(gated_gain, ' = ', activation, store_activation);
                }
            }
        }
        if (!isInput) {
            var responsibility = getVar(this, 'error', 'responsibility', this.error.responsibility);
            if (isOutput) {
                var target = getVar('target');
                buildSentence(responsibility, ' = ', target, ' - ', activation, store_propagation);
                for (id in this.connections.inputs) {
                    if (this.connections.inputs.hasOwnProperty(id)) {
                        input = this.connections.inputs[id];
                        trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                        input_weight = getVar(input, 'weight');
                        buildSentence(input_weight, ' += ', rate, ' * (', responsibility, ' * ', trace, ')', store_propagation);
                    }
                }
                outputs.push(activation.id);
            } else {
                if (!noProjections && !noGates) {
                    var error = getVar('aux');
                    for (id in this.connections.projected) {
                        if (this.connections.projected.hasOwnProperty(id)) {
                            connection = this.connections.projected[id];
                            neuron = connection.to;
                            connection_weight = getVar(connection, 'weight');
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            if (connection.gater) {
                                connection_gain = getVar(connection, 'gain');
                                buildSentence(error, ' += ', neuron_responsibility, ' * ', connection_gain, ' * ', connection_weight, store_propagation);
                            } else {
                                buildSentence(error, ' += ', neuron_responsibility, ' * ', connection_weight, store_propagation);
                            }
                        }
                    }
                    var projected = getVar(this, 'error', 'projected', this.error.projected);
                    //should check derivative var
                    buildSentence(projected, ' = ', derivative, ' * ', error, store_propagation);
                    buildSentence(error, ' = 0', store_propagation);
                    for (id in this.trace.extended) {
                        if (this.trace.extended.hasOwnProperty(id)) {
                            neuron = this.neighboors[id];
                            influence = getVar('aux_2');
                            neuron_old = getVar(neuron, 'old');
                            if (neuron.selfconnection.gater === this) {
                                buildSentence(influence, ' = ', neuron_old, store_propagation);
                            } else {
                                buildSentence(influence, ' = 0', store_propagation);
                            }
                            for (input in this.trace.influences[neuron.ID]) {
                                if (this.trace.influences[neuron.ID].hasOwnProperty(input)) {
                                    connection = this.trace.influences[neuron.ID][input];
                                    connection_weight = getVar(connection, 'weight');
                                    neuron_activation = getVar(connection.from, 'activation');
                                    buildSentence(influence, ' += ', connection_weight, ' * ', neuron_activation, store_propagation);
                                }
                            }
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            buildSentence(error, ' += ', neuron_responsibility, ' * ', influence, store_propagation);
                        }
                    }
                    var gated = getVar(this, 'error', 'gated', this.error.gated);
                    buildSentence(gated, ' = ', derivative, ' * ', error, store_propagation);
                    buildSentence(responsibility, ' = ', projected, ' + ', gated, store_propagation);
                    for (id in this.connections.inputs) {
                        if (this.connections.inputs.hasOwnProperty(id)) {
                            input = this.connections.inputs[id];
                            gradient = getVar('aux');
                            trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                            buildSentence(gradient, ' = ', projected, ' * ', trace, store_propagation);
                            for (id in this.trace.extended) {
                                if (this.trace.extended.hasOwnProperty(id)) {
                                    neuron = this.neighboors[id];
                                    neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                                    xtrace = getVar(this, 'trace', 'extended', neuron.ID, input.ID, this.trace.extended[neuron.ID][input.ID]);
                                    buildSentence(gradient, ' += ', neuron_responsibility, ' * ', xtrace, store_propagation);
                                }
                            }
                            input_weight = getVar(input, 'weight');
                            buildSentence(input_weight, ' += ', rate, ' * ', gradient, store_propagation);
                        }
                    }
                } else if (noGates) {
                    buildSentence(responsibility, ' = 0', store_propagation);
                    for (id in this.connections.projected) {
                        if (this.connections.projected.hasOwnProperty(id)) {
                            connection = this.connections.projected[id];
                            neuron = connection.to;
                            connection_weight = getVar(connection, 'weight');
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            if (connection.gater) {
                                connection_gain = getVar(connection, 'gain');
                                buildSentence(responsibility, ' += ', neuron_responsibility, ' * ', connection_gain, ' * ', connection_weight, store_propagation);
                            } else {
                                buildSentence(responsibility, ' += ', neuron_responsibility, ' * ', connection_weight, store_propagation);
                            }
                        }
                    }
                    buildSentence(responsibility, ' *= ', derivative, store_propagation);
                    for (id in this.connections.inputs) {
                        if (this.connections.inputs.hasOwnProperty(id)) {
                            input = this.connections.inputs[id];
                            trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                            input_weight = getVar(input, 'weight');
                            buildSentence(input_weight, ' += ', rate, ' * (', responsibility, ' * ', trace, ')', store_propagation);
                        }
                    }
                } else if (noProjections) {
                    buildSentence(responsibility, ' = 0', store_propagation);
                    for (id in this.trace.extended) {
                        if (this.trace.extended.hasOwnProperty(id)) {
                            neuron = this.neighboors[id];
                            influence = getVar('aux');
                            neuron_old = getVar(neuron, 'old');
                            if (neuron.selfconnection.gater === this) {
                                buildSentence(influence, ' = ', neuron_old, store_propagation);
                            } else {
                                buildSentence(influence, ' = 0', store_propagation);
                            }
                            for (input in this.trace.influences[neuron.ID]) {
                                if (this.trace.influences[neuron.ID].hasOwnProperty(input)) {
                                    connection = this.trace.influences[neuron.ID][input];
                                    connection_weight = getVar(connection, 'weight');
                                    neuron_activation = getVar(connection.from, 'activation');
                                    buildSentence(influence, ' += ', connection_weight, ' * ', neuron_activation, store_propagation);
                                }
                            }
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            buildSentence(responsibility, ' += ', neuron_responsibility, ' * ', influence, store_propagation);
                        }
                    }
                    buildSentence(responsibility, ' *= ', derivative, store_propagation);
                    for (id in this.connections.inputs) {
                        if (this.connections.inputs.hasOwnProperty(id)) {
                            input = this.connections.inputs[id];
                            gradient = getVar('aux');
                            buildSentence(gradient, ' = 0', store_propagation);
                            for (id in this.trace.extended) {
                                if (this.trace.extended.hasOwnProperty(id)) {
                                    neuron = this.neighboors[id];
                                    neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                                    xtrace = getVar(this, 'trace', 'extended', neuron.ID, input.ID, this.trace.extended[neuron.ID][input.ID]);
                                    buildSentence(gradient, ' += ', neuron_responsibility, ' * ', xtrace, store_propagation);
                                }
                            }
                            input_weight = getVar(input, 'weight');
                            buildSentence(input_weight, ' += ', rate, ' * ', gradient, store_propagation);
                        }
                    }
                }
            }
            buildSentence(bias, ' += ', rate, ' * ', responsibility, store_propagation);
        }
        return {
            memory: varID,
            neurons: neurons + 1,
            inputs: inputs,
            outputs: outputs,
            targets: targets,
            variables: variables,
            activation_sentences: activation_sentences,
            trace_sentences: trace_sentences,
            propagation_sentences: propagation_sentences,
            layers: layers
        };
    }
};
// represents a connection between two neurons
Neuron.connection = function Connection(from, to, weight) {
    if (!from || !to) {
        throw new Error('Connection Error: Invalid neurons');
    }
    this.ID = Neuron.connection.uid();
    this.from = from;
    this.to = to;
    this.weight = weight === undefined ? Math.random() * 0.2 - 0.1 : weight;
    this.gain = 1;
    this.gater = null;
};
// squashing functions
Neuron.squash = {};
// eq. 5 & 5'
Neuron.squash.LOGISTIC = function (x, derivate) {
    if (!derivate) {
        return 1 / (1 + Math.exp(-x));
    }
    var fx = Neuron.squash.LOGISTIC(x);
    return fx * (1 - fx);
};
Neuron.squash.TANH = function (x, derivate) {
    if (derivate) {
        return 1 - Math.pow(Neuron.squash.TANH(x), 2);
    }
    var eP = Math.exp(x);
    var eN = 1 / eP;
    return (eP - eN) / (eP + eN);
};
Neuron.squash.IDENTITY = function (x, derivate) {
    return derivate ? 1 : x;
};
Neuron.squash.HLIM = function (x, derivate) {
    return derivate ? 1 : x > 0 ? 1 : 0;
};
Neuron.squash.RELU = function (x, derivate) {
    if (derivate) {
        return x > 0 ? 1 : 0;
    }
    return x > 0 ? x : 0;
};
// unique ID's
(function () {
    var neurons = 0;
    var connections = 0;
    Neuron.uid = function () {
        neurons = neurons + 1;
        return neurons - 1;
    };
    Neuron.connection.uid = function () {
        connections = connections + 1;
        return connections - 1;
    };
    Neuron.quantity = function () {
        return {
            neurons: neurons,
            connections: connections
        };
    };
}());
},{}],6:[function(require,module,exports){
// export
'use strict';
/*global Trainer*/
if (module) {
    module.exports = Trainer;
}
/*******************************************************************************************
                                        TRAINER
*******************************************************************************************/
function Trainer(network, options) {
    options = options || {};
    this.network = network;
    this.rate = options.rate || 0.2;
    this.iterations = options.iterations || 100000;
    this.error = options.error || 0.005;
    this.cost = options.cost || null;
    this.crossValidate = options.crossValidate || null;
}
Trainer.prototype = {
    // trains any given set to a network
    train: function (set, options) {
        /*jslint nomen: true */
        var error = 1;
        var bucketSize = 0;
        var iterations = 0;
        var abort = false;
        var currentRate;
        var cost;
        if (options && options.cost) {
            cost = options.cost;
        } else if (this.cost) {
            cost = this.cost;
        } else if (Trainer.cost.MSE) {
            cost = Trainer.cost.MSE;
        }
        var crossValidate = false;
        var testSet;
        var trainSet;
        var start = Date.now();

        function shuffle(o) {
            //v1.0
            var j;
            var x;
            var i;
            var n = 0;
            for (i = o.length; i; j = Math.floor(Math.random() * i), i = i - 1, x = o[i], o[i] = o[j], o[j] = x) {
                n = n + 1;
            }
            return o;
        }
        if (options) {
            if (options.iterations) {
                this.iterations = options.iterations;
            }
            if (options.error) {
                this.error = options.error;
            }
            if (options.rate) {
                this.rate = options.rate;
            }
            if (options.cost) {
                this.cost = options.cost;
            }
            if (options.schedule) {
                this.schedule = options.schedule;
            }
            if (options.customLog) {
                // for backward compatibility with code that used customLog
                console.log('Deprecated: use schedule instead of customLog');
                this.schedule = options.customLog;
            }
            if (this.crossValidate) {
                crossValidate = true;
                if (options.crossValidate.testSize) {
                    this.crossValidate.testSize = options.crossValidate.testSize;
                }
                if (options.crossValidate.testError) {
                    this.crossValidate.testError = options.crossValidate.testError;
                }
            }
        }
        currentRate = this.rate;
        if (Array.isArray(this.rate)) {
            bucketSize = Math.floor(this.iterations / this.rate.length);
        }
        if (crossValidate) {
            var numTrain = Math.ceil((1 - this.crossValidate.testSize) * set.length);
            trainSet = set.slice(0, numTrain);
            testSet = set.slice(numTrain);
        }
        var currentSetSize;
        var currentBucket;
        while (!abort && iterations < this.iterations && error > this.error) {
            if (crossValidate && error <= this.crossValidate.testError) {
                break;
            }
            currentSetSize = set.length;
            error = 0;
            if (bucketSize > 0) {
                currentBucket = Math.floor(iterations / bucketSize);
                currentRate = this.rate[currentBucket] || currentRate;
            }
            if (crossValidate) {
                this.trainSet(trainSet, currentRate, cost);
                error += this.test(testSet).error;
                currentSetSize = 1;
            } else {
                error += this.trainSet(set, currentRate, cost);
                currentSetSize = set.length;
            }
            // check error
            iterations = iterations + 1;
            error /= currentSetSize;
            if (options) {
                if (this.schedule && this.schedule.every && iterations % this.schedule.every === 0) {
                    abort = this.schedule.do({
                        error: error,
                        iterations: iterations,
                        rate: currentRate
                    });
                } else if (options.log && iterations % options.log === 0) {
                    console.log('iterations', iterations, 'error', error, 'rate', currentRate);
                }
                if (options.shuffle) {
                    shuffle(set);
                }
            }
        }
        var results = {
            error: error,
            iterations: iterations,
            time: Date.now() - start
        };
        return results;
    },
    // preforms one training epoch and returns the error (private function used in this.train)
    trainSet: function (set, currentRate, costFunction) {
        var input;
        var target;
        var output;
        var errorSum = 0;
        var train;
        for (train in set) {
            if (set.hasOwnProperty(train)) {
                input = set[train].input;
                target = set[train].output;
                output = this.network.activate(input);
                this.network.propagate(currentRate, target);
                errorSum += costFunction(target, output);
            }
        }
        return errorSum;
    },
    // tests a set and returns the error and elapsed time
    test: function (set, options) {
        var error = 0;
        var input, output, target;
        var cost;
        if (options && options.cost) {
            cost = options.cost;
        } else if (this.cost) {
            cost = this.cost;
        } else if (Trainer.cost.MSE) {
            cost = Trainer.cost.MSE;
        }
        var start = Date.now();
        var test;
        for (test in set) {
            if (set.hasOwnProperty(test)) {
                input = set[test].input;
                target = set[test].output;
                output = this.network.activate(input);
                error += cost(target, output);
            }
        }
        error /= set.length;
        var results = {
            error: error,
            time: Date.now() - start
        };
        return results;
    },
    // trains any given set to a network using a WebWorker
    workerTrain: function (set, callback, options) {
        var that = this;
        var error = 1;
        var bucketSize = 0;
        var iterations = 0;
        var currentRate;
        var length = set.length;
        var abort = false;
        var cost;
        if (options && options.cost) {
            cost = options.cost;
        } else if (this.cost) {
            cost = this.cost;
        } else if (Trainer.cost.MSE) {
            cost = Trainer.cost.MSE;
        }
        var start = Date.now();

        function shuffle(o) {
            //v1.0
            var j;
            var x;
            var i;
            var n;
            for (n = 0, i = o.length; i; j = Math.floor(Math.random() * i), i = i - 1, x = o[i], o[i] = o[j], o[j] = x) {
                n = n + 1;
            }
            return o;
        }
        if (options) {
            if (options.iterations) {
                that.iterations = options.iterations;
            }
            if (options.error) {
                that.error = options.error;
            }
            if (options.rate) {
                that.rate = options.rate;
            }
            if (options.cost) {
                that.cost = options.cost;
            }
            if (options.schedule) {
                that.schedule = options.schedule;
            }
            if (options.customLog) {
                // for backward compatibility with code that used customLog
                console.log('Deprecated: use schedule instead of customLog');
                that.schedule = options.customLog;
            }
        }
        // dynamic learning rate
        currentRate = that.rate;
        if (Array.isArray(that.rate)) {
            bucketSize = Math.floor(that.iterations / that.rate.length);
        }
        // create a worker
        var worker = that.network.worker();
        // activate the network
        function activateWorker(input) {
            worker.postMessage({
                action: 'activate',
                input: input,
                memoryBuffer: that.network.optimized.memory
            }, [that.network.optimized.memory.buffer]);
        }
        // backpropagate the network
        function propagateWorker(target) {
            if (bucketSize > 0) {
                var currentBucket = Math.floor(iterations / bucketSize);
                currentRate = that.rate[currentBucket] || currentRate;
            }
            worker.postMessage({
                action: 'propagate',
                target: target,
                rate: currentRate,
                memoryBuffer: that.network.optimized.memory
            }, [that.network.optimized.memory.buffer]);
        }
        var index;
        // train the worker
        worker.onmessage = function (e) {
            // give control of the memory back to the network
            that.network.optimized.ownership(e.data.memoryBuffer);
            if (e.data.action === 'propagate') {
                if (index >= length) {
                    index = 0;
                    iterations = iterations + 1;
                    error /= set.length;
                    // log
                    if (options) {
                        if (that.schedule && that.schedule.every && iterations % that.schedule.every === 0) {
                            abort = that.schedule.do({
                                error: error,
                                iterations: iterations,
                                rate: currentRate
                            });
                        } else if (options.log && iterations % options.log === 0) {
                            console.log('iterations', iterations, 'error', error);
                        }
                        if (options.shuffle) {
                            shuffle(set);
                        }
                    }
                    if (!abort && iterations < that.iterations && error > that.error) {
                        activateWorker(set[index].input);
                    } else {
                        // callback
                        callback({
                            error: error,
                            iterations: iterations,
                            time: Date.now() - start
                        });
                    }
                    error = 0;
                } else {
                    activateWorker(set[index].input);
                }
            }
            if (e.data.action === 'activate') {
                error += cost(set[index].output, e.data.output);
                propagateWorker(set[index].output);
                index = index + 1;
            }
        };
        // kick it
        index = 0;
        activateWorker(set[index].input);
    },
    // trains an XOR to the network
    XOR: function (options) {
        if (this.network.inputs() !== 2 || this.network.outputs() !== 1) {
            throw new Error('Incompatible network (2 inputs, 1 output)');
        }
        var defaults = {
            iterations: 100000,
            log: false,
            shuffle: true,
            cost: Trainer.cost.MSE
        };
        if (options) {
            var i;
            for (i in options) {
                if (options.hasOwnProperty(i)) {
                    defaults[i] = options[i];
                }
            }
        }
        return this.train([{
            input: [
                0,
                0
            ],
            output: [0]
        }, {
            input: [
                1,
                0
            ],
            output: [1]
        }, {
            input: [
                0,
                1
            ],
            output: [1]
        }, {
            input: [
                1,
                1
            ],
            output: [0]
        }], defaults);
    },
    // trains the network to pass a Distracted Sequence Recall test
    DSR: function (options) {
        options = options || {};
        var targets = options.targets || [
            2,
            4,
            7,
            8
        ];
        var distractors = options.distractors || [
            3,
            5,
            6,
            9
        ];
        var prompts = options.prompts || [
            0,
            1
        ];
        var length = options.length || 24;
        var criterion = options.success || 0.95;
        var iterations = options.iterations || 100000;
        var rate = options.rate || 0.1;
        var log = options.log || 0;
        var schedule = options.schedule || {};
        var cost = options.cost || this.cost || Trainer.cost.CROSS_ENTROPY;
        var success = 0;
        var j = 0;
        var i = 0;
        var correct = 0;
        var trial = 0,
            error = 1,
            symbols = targets.length + distractors.length + prompts.length;
        var noRepeat = function (range, avoid) {
            /*jslint bitwise: true */
            var number = Math.random() * range | 0;
            var used = false;
            var p;
            for (p in avoid) {
                if (avoid.hasOwnProperty(p)) {
                    if (number === avoid[p]) {
                        used = true;
                    }
                }
            }
            return used ? noRepeat(range, avoid) : number;
        };
        var equal = function (prediction, output) {
            var p;
            for (p in prediction) {
                if (prediction.hasOwnProperty(p)) {
                    if (Math.round(prediction[p]) !== output[p]) {
                        return false;
                    }
                }
            }
            return true;
        };
        var start = Date.now();
        var sequence;
        var sequenceLength;
        var any;
        var indexes;
        var positions;
        var distractorsCorrect;
        var targetsCorrect;
        var input;
        var output;
        var index;
        var prediction;
        var divideError;
        while (trial < iterations && (success < criterion || trial % 1000 !== 0)) {
            // generate sequence
            sequence = [];
            sequenceLength = length - prompts.length;
            for (i = 0; i < sequenceLength; i = i + 1) {
                /*jslint bitwise: true */
                any = Math.random() * distractors.length | 0;
                sequence.push(distractors[any]);
            }
            indexes = [];
            positions = [];
            for (i = 0; i < prompts.length; i = i + 1) {
                indexes.push(Math.random() * targets.length | 0);
                positions.push(noRepeat(sequenceLength, positions));
            }
            positions = positions.sort();
            for (i = 0; i < prompts.length; i = i + 1) {
                sequence[positions[i]] = targets[indexes[i]];
                sequence.push(prompts[i]);
            }
            //train sequence
            targetsCorrect = 0;
            distractorsCorrect = 0;
            error = 0;
            for (i = 0; i < length; i = i + 1) {
                // generate input from sequence
                input = [];
                for (j = 0; j < symbols; j = j + 1) {
                    input[j] = 0;
                }
                input[sequence[i]] = 1;
                // generate target output
                output = [];
                for (j = 0; j < targets.length; j = j + 1) {
                    output[j] = 0;
                }
                if (i >= sequenceLength) {
                    index = i - sequenceLength;
                    output[indexes[index]] = 1;
                }
                // check result
                prediction = this.network.activate(input);
                if (equal(prediction, output)) {
                    if (i < sequenceLength) {
                        distractorsCorrect = distractorsCorrect + 1;
                    } else {
                        targetsCorrect = targetsCorrect + 1;
                    }
                } else {
                    this.network.propagate(rate, output);
                }
                error += cost(output, prediction);
                if (distractorsCorrect + targetsCorrect === length) {
                    correct = correct + 1;
                }
            }
            // calculate error
            if (trial % 1000 === 0) {
                correct = 0;
            }
            trial = trial + 1;
            divideError = trial % 1000;
            divideError = divideError === 0 ? 1000 : divideError;
            success = correct / divideError;
            error /= length;
            // log
            if (log && trial % log === 0) {
                console.log('iterations:', trial, ' success:', success, ' correct:', correct, ' time:', Date.now() - start, ' error:', error);
            }
            if (schedule.do && schedule.every && trial % schedule.every === 0) {
                schedule.do({
                    iterations: trial,
                    success: success,
                    error: error,
                    time: Date.now() - start,
                    correct: correct
                });
            }
        }
        return {
            iterations: trial,
            success: success,
            error: error,
            time: Date.now() - start
        };
    },
    // train the network to learn an Embeded Reber Grammar
    ERG: function (options) {
        options = options || {};
        var iterations = options.iterations || 150000;
        var criterion = options.error || 0.05;
        var rate = options.rate || 0.1;
        var log = options.log || 500;
        var cost = options.cost || this.cost || Trainer.cost.CROSS_ENTROPY;
        // gramar node
        var Node = function () {
            this.paths = [];
        };
        Node.prototype = {
            connect: function (node, value) {
                this.paths.push({
                    node: node,
                    value: value
                });
                return this;
            },
            any: function () {
                /*jslint bitwise: true */
                if (this.paths.length === 0) {
                    return false;
                }
                var index = Math.random() * this.paths.length | 0;
                return this.paths[index];
            },
            test: function (value) {
                var i;
                for (i in this.paths) {
                    if (this.paths.hasOwnProperty(i)) {
                        if (this.paths[i].value === value) {
                            return this.paths[i];
                        }
                    }
                }
                return false;
            }
        };
        var reberGrammar = function () {
            // build a reber grammar
            var output = new Node();
            var n1 = new Node().connect(output, 'E');
            var n2 = new Node().connect(n1, 'S');
            var n3 = new Node().connect(n1, 'V').connect(n2, 'P');
            var n4 = new Node().connect(n2, 'X');
            n4.connect(n4, 'S');
            var n5 = new Node().connect(n3, 'V');
            n5.connect(n5, 'T');
            n2.connect(n5, 'X');
            var n6 = new Node().connect(n4, 'T').connect(n5, 'P');
            var input = new Node().connect(n6, 'B');
            return {
                input: input,
                output: output
            };
        };
        // build an embeded reber grammar
        var embededReberGrammar = function () {
            var reber1 = reberGrammar();
            var reber2 = reberGrammar();
            var output = new Node();
            var n1 = new Node().connect(output, 'E');
            reber1.output.connect(n1, 'T');
            reber2.output.connect(n1, 'P');
            var n2 = new Node().connect(reber1.input, 'P').connect(reber2.input, 'T');
            var input = new Node().connect(n2, 'B');
            return {
                input: input,
                output: output
            };
        };
        // generate an ERG sequence
        var generate = function () {
            var node = embededReberGrammar().input;
            var next = node.any();
            var str = '';
            while (next) {
                str += next.value;
                next = next.node.any();
            }
            return str;
        };
        // test if a string matches an embeded reber grammar
        var test = function (str) {
            var node = embededReberGrammar().input;
            var i = 0;
            var ch = str.charAt(i);
            var next;
            while (i < str.length) {
                next = node.test(ch);
                if (!next) {
                    return false;
                }
                node = next.node;
                i = i + 1;
                ch = str.charAt(i);
            }
            return true;
        };
        // helper to check if the output and the target vectors match
        var different = function (array1, array2) {
            var max1 = 0;
            var i1 = -1;
            var max2 = 0;
            var i2 = -1;
            var i;
            for (i in array1) {
                if (array1.hasOwnProperty(i)) {
                    if (array1[i] > max1) {
                        max1 = array1[i];
                        i1 = i;
                    }
                    if (array2[i] > max2) {
                        max2 = array2[i];
                        i2 = i;
                    }
                }
            }
            return i1 !== i2;
        };
        var iteration = 0;
        var error = 1;
        var table = {
            'B': 0,
            'P': 1,
            'T': 2,
            'X': 3,
            'S': 4,
            'E': 5
        };
        var start = Date.now();
        var i;
        var sequence;
        var read;
        var predict;
        var input;
        var target;
        var j;
        var output;
        while (iteration < iterations && error > criterion) {
            i = 0;
            error = 0;
            // ERG sequence to learn
            sequence = generate();
            // input
            read = sequence.charAt(i);
            // target
            predict = sequence.charAt(i + 1);
            // train
            while (i < sequence.length - 1) {
                input = [];
                target = [];
                for (j = 0; j < 6; j = j + 1) {
                    input[j] = 0;
                    target[j] = 0;
                }
                input[table[read]] = 1;
                target[table[predict]] = 1;
                output = this.network.activate(input);
                if (different(output, target)) {
                    this.network.propagate(rate, target);
                }
                i = i + 1;
                read = sequence.charAt(i);
                predict = sequence.charAt(i + 1);
                error += cost(target, output);
            }
            error /= sequence.length;
            iteration = iteration + 1;
            if (iteration % log === 0) {
                console.log('iterations:', iteration, ' time:', Date.now() - start, ' error:', error);
            }
        }
        return {
            iterations: iteration,
            error: error,
            time: Date.now() - start,
            test: test,
            generate: generate
        };
    },
    timingTask: function (options) {
        if (this.network.inputs() !== 2 || this.network.outputs() !== 1) {
            throw new Error('Invalid Network: must have 2 inputs and one output');
        }
        if (options === undefined) {
            options = {};
        }
        // helper
        function getSamples(trainingSize, testSize) {
            // sample size
            var size = trainingSize + testSize;
            // generate samples
            var t = 0;
            var set = [];
            var i;
            for (i = 0; i < size; i = i + 1) {
                set.push({
                    input: [
                        0,
                        0
                    ],
                    output: [0]
                });
            }
            var n;
            var j;
            var k;
            while (t < size - 20) {
                n = Math.round(Math.random() * 20);
                set[t].input[0] = 1;
                for (j = t; j <= t + n; j = j + 1) {
                    set[j].input[1] = n / 20;
                    set[j].output[0] = 0.5;
                }
                t += n;
                n = Math.round(Math.random() * 20);
                for (k = t + 1; k <= t + n && k < size; k = k + 1) {
                    set[k].input[1] = set[t].input[1];
                }
                t += n;
            }
            // separate samples between train and test sets
            var trainingSet = [];
            var testSet = [];
            var l;
            for (l = 0; l < size; l = l + 1) {
                (l < trainingSize ? trainingSet : testSet).push(set[l]);
            }
            // return samples
            return {
                train: trainingSet,
                test: testSet
            };
        }
        var iterations = options.iterations || 200;
        var error = options.error || 0.005;
        var rate = options.rate || [
            0.03,
            0.02
        ];
        var log = options.log === false ? false : options.log || 10;
        var cost = options.cost || this.cost || Trainer.cost.MSE;
        var trainingSamples = options.trainSamples || 7000;
        var testSamples = options.trainSamples || 1000;
        // samples for training and testing
        var samples = getSamples(trainingSamples, testSamples);
        // train
        var result = this.train(samples.train, {
            rate: rate,
            log: log,
            iterations: iterations,
            error: error,
            cost: cost
        });
        return {
            train: result,
            test: this.test(samples.test)
        };
    }
};
// Built-in cost functions
Trainer.cost = {
    // Eq. 9
    CROSS_ENTROPY: function (target, output) {
        var crossentropy = 0;
        var i;
        for (i in output) {
            if (output.hasOwnProperty(i)) {
                crossentropy -= target[i] * Math.log(output[i] + 1e-15) + (1 - target[i]) * Math.log(1 + 1e-15 - output[i]); // +1e-15 is a tiny push away to avoid Math.log(0)
            }
        }
        return crossentropy;
    },
    MSE: function (target, output) {
        var mse = 0;
        var i;
        for (i in output) {
            if (output.hasOwnProperty(i)) {
                mse += Math.pow(target[i] - output[i], 2);
            }
        }
        return mse / output.length;
    },
    BINARY: function (target, output) {
        var misses = 0;
        var i;
        for (i in output) {
            if (output.hasOwnProperty(i)) {
                misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);
            }
        }
        return misses;
    }
};
},{}]},{},[1]);
var Neuron = NodeNeuralNetwork.Neuron, Layer = NodeNeuralNetwork.Layer, Network = NodeNeuralNetwork.Network, Trainer = NodeNeuralNetwork.Trainer, Architect = NodeNeuralNetwork.Architect;
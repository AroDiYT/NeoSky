'use strict';
/*global Layer*/
/*jslint bitwise: true */
// export
if (module) {
    //CHECK THIS GLOBAL VAR
    module.exports = Layer;
}
// import
var Neuron = require('./neuron');
var Network = require('./network');
/*******************************************************************************************
                                            LAYER
*******************************************************************************************/
function Layer(size) {
    this.size = size || 0;
    this.listNeurons = [];
    this.connectedTo = [];
    var neuronAdded;
    for (neuronAdded = 0; neuronAdded < this.size; neuronAdded = neuronAdded + 1) {
        this.listNeurons.push(new Neuron());
    }
}
Layer.prototype = {
    activateNeurons: function (input) {
        var activations = [];
        var id;
        var neuron;
        var activation;
        if (input !== undefined) {
            if (input.length !== this.size) {
                throw new Error('INPUT size and LAYER size must be the same to activate!');
            }
            for (id in this.listNeurons) {
                if (this.listNeurons.hasOwnProperty(id)) {
                    neuron = this.listNeurons[id];
                    activation = neuron.activate(input[id]);
                    activations.push(activation);
                }
            }
        } else {
            for (id in this.listNeurons) {
                if (this.listNeurons.hasOwnProperty(id)) {
                    neuron = this.listNeurons[id];
                    activation = neuron.activate();
                    activations.push(activation);
                }
            }
        }
        return activations;
    },
    // propagates the error on all the neurons of the layer
    propagate: function (rate, target) {
        var id;
        var neuron;
        if (target !== undefined) {
            if (target.length !== this.size) {
                throw new Error('TARGET size and LAYER size must be the same to propagate!');
            }
            for (id = this.listNeurons.length - 1; id >= 0; id = id - 1) {
                neuron = this.listNeurons[id];
                neuron.propagate(rate, target[id]);
            }
        } else {
            for (id = this.listNeurons.length - 1; id >= 0; id = id - 1) {
                neuron = this.listNeurons[id];
                neuron.propagate(rate);
            }
        }
    },
    // projects a connection from this layer to another one
    project: function (layer, type, weights) {
        if (layer instanceof Network) {
            layer = layer.layers.input;
        }
        if (layer instanceof Layer) {
            if (!this.connected(layer)) {
                return new Layer.connection(this, layer, type, weights);
            }
        } else {
            throw new Error('Invalid argument, you can only project connections to LAYERS and NETWORKS!');
        }
    },
    // gates a connection betwenn two layers
    gate: function (connection, type) {
        var id;
        var neuron;
        var gater;
        var gated;
        var input;
        var projected;
        if (type === Layer.gateType.INPUT) {
            if (connection.to.size !== this.size) {
                throw new Error('GATER layer and CONNECTION.TO layer must be the same size in order to gate!');
            }
            for (id in connection.to.listNeurons) {
                if (connection.to.listNeurons.hasOwnProperty(id)) {
                    neuron = connection.to.listNeurons[id];
                    gater = this.listNeurons[id];
                    for (input in neuron.connections.inputs) {
                        if (neuron.connections.inputs.hasOwnProperty(input)) {
                            gated = neuron.connections.inputs[input];
                            if (connection.connections.hasOwnProperty(gated.ID)) {
                                gater.gate(gated);
                            }
                        }
                    }
                }
            }
        } else if (type === Layer.gateType.OUTPUT) {
            if (connection.from.size !== this.size) {
                throw new Error('GATER layer and CONNECTION.FROM layer must be the same size in order to gate!');
            }
            for (id in connection.from.listNeurons) {
                if (connection.from.listNeurons.hasOwnProperty(id)) {
                    neuron = connection.from.listNeurons[id];
                    gater = this.listNeurons[id];
                    for (projected in neuron.connections.projected) {
                        if (neuron.connections.projected.hasOwnProperty(projected)) {
                            gated = neuron.connections.projected[projected];
                            if (connection.connections.hasOwnProperty(gated.ID)) {
                                gater.gate(gated);
                            }
                        }
                    }
                }
            }
        } else if (type === Layer.gateType.ONE_TO_ONE) {
            if (connection.size !== this.size) {
                throw new Error('The number of GATER UNITS must be the same as the number of CONNECTIONS to gate!');
            }
            for (id in connection.list) {
                if (connection.list.hasOwnProperty(id)) {
                    gater = this.listNeurons[id];
                    gated = connection.list[id];
                    gater.gate(gated);
                }
            }
        }
        connection.gatedfrom.push({
            layer: this,
            type: type
        });
    },
    // true or false whether the whole layer is self-connected or not
    selfconnected: function () {
        var id;
        var neuron;
        for (id in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(id)) {
                neuron = this.listNeurons[id];
                if (!neuron.selfconnected()) {
                    return false;
                }
            }
        }
        return true;
    },
    // true of false whether the layer is connected to another layer (parameter) or not
    connected: function (layer) {
        // Check if ALL to ALL connection
        var connections = 0;
        var here;
        var from;
        var to;
        var connected;
        var there;
        for (here in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(here)) {
                for (there in layer.listNeurons) {
                    if (layer.listNeurons.hasOwnProperty(there)) {
                        from = this.listNeurons[here];
                        to = layer.listNeurons[there];
                        connected = from.connected(to);
                        if (connected.type === 'projected') {
                            connections = connections + 1;
                        }
                    }
                }
            }
        }
        if (connections === this.size * layer.size) {
            return Layer.connectionType.ALL_TO_ALL;
        }
        // Check if ONE to ONE connection
        connections = 0;
        var neuron;
        for (neuron in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(neuron)) {
                from = this.listNeurons[neuron];
                to = layer.listNeurons[neuron];
                connected = from.connected(to);
                if (connected.type === 'projected') {
                    connections += 1;
                }
            }
        }
        if (connections === this.size) {
            return Layer.connectionType.ONE_TO_ONE;
        }
    },
    // clears all the neuorns in the layer
    clear: function () {
        var id;
        var neuron;
        for (id in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(id)) {
                neuron = this.listNeurons[id];
                neuron.clear();
            }
        }
    },
    // resets all the neurons in the layer
    reset: function () {
        var id;
        var neuron;
        for (id in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(id)) {
                neuron = this.listNeurons[id];
                neuron.reset();
            }
        }
    },
    // returns all the neurons in the layer (array)
    neurons: function () {
        return this.listNeurons;
    },
    addNeuron: function (neuron) {
        if (neuron instanceof Neuron) {
            this.listNeurons.push(neuron);
            this.size = this.size + 1;
        } else {
            throw new Error('Layer:addNeuron wait a neuron Object.');
        }
    },
    set: function (options) {
        options = options || {};
        var i;
        var neuron;
        for (i in this.listNeurons) {
            if (this.listNeurons.hasOwnProperty(i)) {
                neuron = this.listNeurons[i];
                if (options.label) {
                    neuron.label = options.label + '_' + neuron.ID;
                }
                if (options.squash) {
                    neuron.squash = options.squash;
                }
                if (options.bias) {
                    neuron.bias = options.bias;
                }
            }
        }
        return this;
    }
};
// represents a connection from one layer to another, and keeps track of its weight and gain
Layer.connection = function LayerConnection(fromLayer, toLayer, type, weights) {
    this.ID = Layer.connection.uid();
    this.from = fromLayer;
    this.to = toLayer;
    this.selfconnection = toLayer === fromLayer;
    this.type = type;
    this.connections = {};
    this.list = [];
    this.size = 0;
    this.gatedfrom = [];
    var here;
    var there;
    var from;
    var to;
    var connection;
    var neuron;
    if (this.type === undefined) {
        if (fromLayer === toLayer) {
            this.type = Layer.connectionType.ONE_TO_ONE;
        } else {
            this.type = Layer.connectionType.ALL_TO_ALL;
        }
    }
    if (this.type === Layer.connectionType.ALL_TO_ALL || this.type === Layer.connectionType.ALL_TO_ELSE) {
        for (here in this.from.listNeurons) {
            if (this.from.listNeurons.hasOwnProperty(here)) {
                for (there in this.to.listNeurons) {
                    if (this.to.listNeurons.hasOwnProperty(there)) {
                        from = this.from.listNeurons[here];
                        to = this.to.listNeurons[there];
                        if (this.type !== Layer.connectionType.ALL_TO_ELSE || from !== to) {
                            connection = from.project(to, weights);
                            this.connections[connection.ID] = connection;
                            this.size = this.list.push(connection);
                        }
                    }
                }
            }
        }
    } else if (this.type === Layer.connectionType.ONE_TO_ONE) {
        for (neuron in this.from.listNeurons) {
            if (this.from.listNeurons.hasOwnProperty(neuron)) {
                from = this.from.listNeurons[neuron];
                to = this.to.listNeurons[neuron];
                connection = from.project(to, weights);
                this.connections[connection.ID] = connection;
                this.size = this.list.push(connection);
            }
        }
    }
    fromLayer.connectedTo.push(this);
};
// types of connections
Layer.connectionType = {};
Layer.connectionType.ALL_TO_ALL = 'ALL TO ALL';
Layer.connectionType.ONE_TO_ONE = 'ONE TO ONE';
Layer.connectionType.ALL_TO_ELSE = 'ALL TO ELSE';
// types of gates
Layer.gateType = {};
Layer.gateType.INPUT = 'INPUT';
Layer.gateType.OUTPUT = 'OUTPUT';
Layer.gateType.ONE_TO_ONE = 'ONE TO ONE';
(function () {
    var connections = 0;
    Layer.connection.uid = function () {
        connections = connections + 1;
        return connections - 1;
    };
}());
'use strict';
/*global Neuron*/
// export
if (module) {
    module.exports = Neuron;
}
/******************************************************************************************
                                         NEURON
*******************************************************************************************/
function Neuron() {
    this.ID = Neuron.uid();
    this.label = null;
    this.connections = {
        inputs: {},
        projected: {},
        gated: {}
    };
    this.error = {
        responsibility: 0,
        projected: 0,
        gated: 0
    };
    this.trace = {
        elegibility: {},
        extended: {},
        influences: {}
    };
    this.state = 0;
    this.old = 0;
    this.activation = 0;
    this.selfconnection = new Neuron.connection(this, this, 0);
    // weight = 0 -> not connected
    this.squash = Neuron.squash.LOGISTIC;
    this.neighboors = {};
    this.bias = Math.random() * 0.2 - 0.1;
}
Neuron.prototype = {
    // activate the neuron
    activate: function (input) {
        // activation from enviroment (for input neurons)
        if (input !== undefined) {
            this.activation = input;
            this.derivative = 0;
            this.bias = 0;
            return this.activation;
        }
        // old state
        this.old = this.state;
        // eq. 15
        this.state = this.selfconnection.gain * this.selfconnection.weight * this.state + this.bias;
        var i;
        for (i in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(i)) {
                input = this.connections.inputs[i];
                if (input.gater) {
                    this.state += input.from.activation * input.weight * input.gain;
                }
            }
        }
        for (i in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(i)) {
                input = this.connections.inputs[i];
                if (!input.gater) {
                    this.state += input.from.activation * input.weight;
                }
            }
        }
        // eq. 16
        this.activation = this.squash(this.state);
        // f'(s)
        this.derivative = this.squash(this.state, true);
        // update traces
        var influences = [];
        var id;
        var xtrace;
        var neuron;
        var influence;
        var incoming;
        for (id in this.trace.extended) {
            if (this.trace.extended.hasOwnProperty(id)) {
                // extended elegibility trace
                xtrace = this.trace.extended[id];
                neuron = this.neighboors[id];
                // if gated neuron's selfconnection is gated by this unit, the influence keeps track of the neuron's old state
                influence = neuron.selfconnection.gater === this ? neuron.old : 0;
                // index runs over all the incoming connections to the gated neuron that are gated by this unit
                for (incoming in this.trace.influences[neuron.ID]) {
                    if (this.trace.influences[neuron.ID].hasOwnProperty(incoming)) {
                        // captures the effect that has an input connection to this unit, on a neuron that is gated by this unit
                        influence += this.trace.influences[neuron.ID][incoming].weight * this.trace.influences[neuron.ID][incoming].from.activation;
                    }
                }
                influences[neuron.ID] = influence;
            }
        }
        for (i in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(i)) {
                input = this.connections.inputs[i];
                // elegibility trace - Eq. 17
                this.trace.elegibility[input.ID] = this.selfconnection.gain * this.selfconnection.weight * this.trace.elegibility[input.ID] + input.gain * input.from.activation;
                for (id in this.trace.extended) {
                    if (this.trace.extended.hasOwnProperty(id)) {
                        // extended elegibility trace
                        xtrace = this.trace.extended[id];
                        neuron = this.neighboors[id];
                        influence = influences[neuron.ID];
                        // eq. 18
                        xtrace[input.ID] = neuron.selfconnection.gain * neuron.selfconnection.weight * xtrace[input.ID] + this.derivative * this.trace.elegibility[input.ID] * influence;
                    }
                }
            }
        }
        var connection;
        //  update gated connection's gains
        for (connection in this.connections.gated) {
            if (this.connections.gated.hasOwnProperty(connection)) {
                this.connections.gated[connection].gain = this.activation;
            }
        }
        return this.activation;
    },
    // back-propagate the error
    propagate: function (rate, target) {
        // error accumulator
        var error = 0;
        // whether or not this neuron is in the output layer
        var isOutput = target !== undefined;
        var id;
        var input;
        var neuron;
        // output neurons get their error from the enviroment
        if (isOutput) {
            this.error.responsibility = this.error.projected = target - this.activation; // Eq. 10
        } else {
            var connection;
            // the rest of the neuron compute their error responsibilities by backpropagation
            // error responsibilities from all the connections projected from this neuron
            for (id in this.connections.projected) {
                if (this.connections.projected.hasOwnProperty(id)) {
                    connection = this.connections.projected[id];
                    neuron = connection.to;
                    // Eq. 21
                    error += neuron.error.responsibility * connection.gain * connection.weight;
                }
            }
            // projected error responsibility
            this.error.projected = this.derivative * error;
            error = 0;
            var influence;
            // error responsibilities from all the connections gated by this neuron
            for (id in this.trace.extended) {
                if (this.trace.extended.hasOwnProperty(id)) {
                    neuron = this.neighboors[id];
                    // gated neuron
                    influence = neuron.selfconnection.gater === this ? neuron.old : 0;
                    // if gated neuron's selfconnection is gated by this neuron
                    // index runs over all the connections to the gated neuron that are gated by this neuron
                    for (input in this.trace.influences[id]) {
                        if (this.trace.influences[id].hasOwnProperty(input)) {
                            // captures the effect that the input connection of this neuron have, on a neuron which its input/s is/are gated by this neuron
                            influence += this.trace.influences[id][input].weight * this.trace.influences[neuron.ID][input].from.activation;
                        }
                    }
                    // eq. 22
                    error += neuron.error.responsibility * influence;
                }
            }
            // gated error responsibility
            this.error.gated = this.derivative * error;
            // error responsibility - Eq. 23
            this.error.responsibility = this.error.projected + this.error.gated;
        }
        // learning rate
        rate = rate || 0.1;
        var gradient;
        // adjust all the neuron's incoming connections
        for (id in this.connections.inputs) {
            if (this.connections.inputs.hasOwnProperty(id)) {
                input = this.connections.inputs[id];
                // Eq. 24
                gradient = this.error.projected * this.trace.elegibility[input.ID];
                for (id in this.trace.extended) {
                    if (this.trace.extended.hasOwnProperty(id)) {
                        neuron = this.neighboors[id];
                        gradient += neuron.error.responsibility * this.trace.extended[neuron.ID][input.ID];
                    }
                }
                input.weight += rate * gradient; // adjust weights - aka learn
            }
        }
        // adjust bias
        this.bias += rate * this.error.responsibility;
    },
    project: function (neuron, weight) {
        // self-connection
        if (neuron === this) {
            this.selfconnection.weight = 1;
            return this.selfconnection;
        }
        // check if connection already exists
        var connected = this.connected(neuron);
        if (connected && connected.type === 'projected') {
            // update connection
            if (weight !== undefined) {
                connected.connection.weight = weight;
            }
            // return existing connection
            return connected.connection;
        }
        // create a new connection
        var connection = new Neuron.connection(this, neuron, weight);
        // reference all the connections and traces
        this.connections.projected[connection.ID] = connection;
        this.neighboors[neuron.ID] = neuron;
        neuron.connections.inputs[connection.ID] = connection;
        neuron.trace.elegibility[connection.ID] = 0;
        var id;
        var trace;
        for (id in neuron.trace.extended) {
            if (neuron.trace.extended.hasOwnProperty(id)) {
                trace = neuron.trace.extended[id];
                trace[connection.ID] = 0;
            }
        }
        return connection;
    },
    gate: function (connection) {
        // add connection to gated list
        this.connections.gated[connection.ID] = connection;
        var neuron = connection.to;
        var xtrace;
        if (!this.trace.extended.hasOwnProperty(neuron.ID)) {
            // extended trace
            this.neighboors[neuron.ID] = neuron;
            xtrace = this.trace.extended[neuron.ID] = {};
            var id;
            var input;
            for (id in this.connections.inputs) {
                if (this.connections.inputs.hasOwnProperty(id)) {
                    input = this.connections.inputs[id];
                    xtrace[input.ID] = 0;
                }
            }
        }
        // keep track
        if (this.trace.influences.hasOwnProperty(neuron.ID)) {
            this.trace.influences[neuron.ID].push(connection);
        } else {
            this.trace.influences[neuron.ID] = [connection];
        }
        // set gater
        connection.gater = this;
    },
    // returns true or false whether the neuron is self-connected or not
    selfconnected: function () {
        return this.selfconnection.weight !== 0;
    },
    // returns true or false whether the neuron is connected to another neuron (parameter)
    connected: function (neuron) {
        var result = {
            type: null,
            connection: false
        };
        if (this === neuron) {
            if (this.selfconnected()) {
                result.type = 'selfconnection';
                result.connection = this.selfconnection;
                return result;
            }
            return false;
        }
        var type;
        var connection;
        for (type in this.connections) {
            if (this.connections.hasOwnProperty(type)) {
                for (connection in this.connections[type]) {
                    if (this.connections[type].hasOwnProperty(connection)) {
                        connection = this.connections[type][connection];
                        if (connection.to === neuron) {
                            result.type = type;
                            result.connection = connection;
                            return result;
                        }
                        if (connection.from === neuron) {
                            result.type = type;
                            result.connection = connection;
                            return result;
                        }
                    }
                }
            }
        }
        return false;
    },
    // clears all the traces (the neuron forgets it's context, but the connections remain intact)
    clear: function () {
        var trace;
        var extended;
        for (trace in this.trace.elegibility) {
            if (this.trace.elegibility.hasOwnProperty(trace)) {
                this.trace.elegibility[trace] = 0;
            }
        }
        for (trace in this.trace.extended) {
            if (this.trace.extended.hasOwnProperty(trace)) {
                for (extended in this.trace.extended[trace]) {
                    if (this.trace.extended[trace].hasOwnProperty(extended)) {
                        this.trace.extended[trace][extended] = 0;
                    }
                }
            }
        }
        this.error.responsibility = this.error.projected = this.error.gated = 0;
    },
    // all the connections are randomized and the traces are cleared
    reset: function () {
        this.clear();
        var type;
        var connection;
        for (type in this.connections) {
            if (this.connections.hasOwnProperty(type)) {
                for (connection in this.connections[type]) {
                    if (this.connections[type].hasOwnProperty(connection)) {
                        this.connections[type][connection].weight = Math.random() * 0.2 - 0.1;
                    }
                }
            }
        }
        this.bias = Math.random() * 0.2 - 0.1;
        this.old = this.state = this.activation = 0;
    },
    // hardcodes the behaviour of the neuron into an optimized function
    optimize: function (optimized, layer) {
        /*jslint nomen: true*/
        optimized = optimized || {};
        var store_activation = [];
        var store_trace = [];
        var store_propagation = [];
        var varID = optimized.memory || 0;
        var neurons = optimized.neurons || 1;
        var inputs = optimized.inputs || [];
        var input;
        var neuron_responsibility;
        var trace;
        var derivative;
        var gradient;
        var xtrace;
        var influence;
        var neuron_old;
        var bias;
        var initialized;
        var incoming;
        var incoming_weight;
        var incoming_activation;
        var connection_gain;
        var connection;
        var neuron;
        var neuron_activation;
        var connection_weight;
        var input_weight;
        var targets = optimized.targets || [];
        var outputs = optimized.outputs || [];
        var variables = optimized.variables || {};
        var activation_sentences = optimized.activation_sentences || [];
        var trace_sentences = optimized.trace_sentences || [];
        var propagation_sentences = optimized.propagation_sentences || [];
        var layers = optimized.layers || {
            __count: 0,
            __neuron: 0
        };
        // allocate sentences
        var allocate = function (store) {
            var allocated = layers.hasOwnProperty(layer) && store[layers.__count];
            if (!allocated) {
                layers.__count = store.push([]) - 1;
                layers[layer] = layers.__count;
            }
        };
        allocate(activation_sentences);
        allocate(trace_sentences);
        allocate(propagation_sentences);
        var currentLayer = layers.__count;
        // get/reserve space in memory by creating a unique ID for a variablel
        var getVar = function () {
            var args = Array.prototype.slice.call(arguments);
            var id;
            if (args.length === 1) {
                if (args[0] === 'target') {
                    id = 'target_' + targets.length;
                    targets.push(varID);
                } else {
                    id = args[0];
                }
                if (variables.hasOwnProperty(id)) {
                    return variables[id];
                }
                varID = varID + 1;
                variables[id] = {
                    value: 0,
                    id: varID - 1
                };
                return variables[id];
            }
            var extended = args.length > 2;
            var value;
            if (extended) {
                value = args.pop();
            }
            var unit = args.shift();
            var prop = args.pop();
            if (!extended) {
                value = unit[prop];
            }
            id = prop + '_';
            var property;
            for (property in args) {
                if (args.hasOwnProperty(property)) {
                    id += args[property] + '_';
                }
            }
            id += unit.ID;
            if (variables.hasOwnProperty(id)) {
                return variables[id];
            }
            varID = varID + 1;
            variables[id] = {
                value: value,
                id: varID - 1
            };
            return variables[id];
        };
        // build sentence
        var buildSentence = function () {
            var args = Array.prototype.slice.call(arguments);
            var store = args.pop();
            var sentence = '';
            var i;
            for (i in args) {
                if (args.hasOwnProperty(i)) {
                    if (typeof args[i] === 'string') {
                        sentence += args[i];
                    } else {
                        sentence += 'F[' + args[i].id + ']';
                    }
                }
            }
            store.push(sentence + ';');
        };
        // helper to check if an object is empty
        var isEmpty = function (obj) {
            var prop;
            for (prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }
            return true;
        };
        // characteristics of the neuron
        var noProjections = isEmpty(this.connections.projected);
        var noGates = isEmpty(this.connections.gated);
        var isInput = layer === 'input' ? true : isEmpty(this.connections.inputs);
        var isOutput = layer === 'output' ? true : noProjections && noGates;
        // optimize neuron's behaviour
        var rate = getVar('rate');
        var activation = getVar(this, 'activation');
        var id;
        if (isInput) {
            inputs.push(activation.id);
        } else {
            activation_sentences[currentLayer].push(store_activation);
            trace_sentences[currentLayer].push(store_trace);
            propagation_sentences[currentLayer].push(store_propagation);
            var old = getVar(this, 'old');
            var state = getVar(this, 'state');
            bias = getVar(this, 'bias');
            var self_gain;
            if (this.selfconnection.gater) {
                self_gain = getVar(this.selfconnection, 'gain');
            }
            var self_weight;
            if (this.selfconnected()) {
                self_weight = getVar(this.selfconnection, 'weight');
            }
            buildSentence(old, ' = ', state, store_activation);
            if (this.selfconnected()) {
                if (this.selfconnection.gater) {
                    buildSentence(state, ' = ', self_gain, ' * ', self_weight, ' * ', state, ' + ', bias, store_activation);
                } else {
                    buildSentence(state, ' = ', self_weight, ' * ', state, ' + ', bias, store_activation);
                }
            } else {
                buildSentence(state, ' = ', bias, store_activation);
            }
            var i;
            var input_activation;
            var input_gain;
            for (i in this.connections.inputs) {
                if (this.connections.inputs.hasOwnProperty(i)) {
                    input = this.connections.inputs[i];
                    input_activation = getVar(input.from, 'activation');
                    input_weight = getVar(input, 'weight');
                    if (input.gater) {
                        input_gain = getVar(input, 'gain');
                        buildSentence(state, ' += ', input_activation, ' * ', input_weight, ' * ', input_gain, store_activation);
                    } else {
                        buildSentence(state, ' += ', input_activation, ' * ', input_weight, store_activation);
                    }
                }
            }
            derivative = getVar(this, 'derivative');
            switch (this.squash) {
            case Neuron.squash.LOGISTIC:
                buildSentence(activation, ' = (1 / (1 + Math.exp(-', state, ')))', store_activation);
                buildSentence(derivative, ' = ', activation, ' * (1 - ', activation, ')', store_activation);
                break;
            case Neuron.squash.TANH:
                var eP = getVar('aux');
                var eN = getVar('aux_2');
                buildSentence(eP, ' = Math.exp(', state, ')', store_activation);
                buildSentence(eN, ' = 1 / ', eP, store_activation);
                buildSentence(activation, ' = (', eP, ' - ', eN, ') / (', eP, ' + ', eN, ')', store_activation);
                buildSentence(derivative, ' = 1 - (', activation, ' * ', activation, ')', store_activation);
                break;
            case Neuron.squash.IDENTITY:
                buildSentence(activation, ' = ', state, store_activation);
                buildSentence(derivative, ' = 1', store_activation);
                break;
            case Neuron.squash.HLIM:
                buildSentence(activation, ' = +(', state, ' > 0)', store_activation);
                buildSentence(derivative, ' = 1', store_activation);
                break;
            case Neuron.squash.RELU:
                buildSentence(activation, ' = ', state, ' > 0 ? ', state, ' : 0', store_activation);
                buildSentence(derivative, ' = ', state, ' > 0 ? 1 : 0', store_activation);
                break;
            }
            for (id in this.trace.extended) {
                if (this.trace.extended.hasOwnProperty(id)) {
                    // calculate extended elegibility traces in advance
                    xtrace = this.trace.extended[id];
                    neuron = this.neighboors[id];
                    influence = getVar('influences[' + neuron.ID + ']');
                    neuron_old = getVar(neuron, 'old');
                    initialized = false;
                    if (neuron.selfconnection.gater === this) {
                        buildSentence(influence, ' = ', neuron_old, store_trace);
                        initialized = true;
                    }
                    for (incoming in this.trace.influences[neuron.ID]) {
                        if (this.trace.influences[neuron.ID].hasOwnProperty(incoming)) {
                            incoming_weight = getVar(this.trace.influences[neuron.ID][incoming], 'weight');
                            incoming_activation = getVar(this.trace.influences[neuron.ID][incoming].from, 'activation');
                            if (initialized) {
                                buildSentence(influence, ' += ', incoming_weight, ' * ', incoming_activation, store_trace);
                            } else {
                                buildSentence(influence, ' = ', incoming_weight, ' * ', incoming_activation, store_trace);
                                initialized = true;
                            }
                        }
                    }
                }
            }
            var neuron_self_weight;
            var neuron_self_gain;
            for (i in this.connections.inputs) {
                if (this.connections.inputs.hasOwnProperty(i)) {
                    input = this.connections.inputs[i];
                    if (input.gater) {
                        input_gain = getVar(input, 'gain');
                    }
                    input_activation = getVar(input.from, 'activation');
                    trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                    if (this.selfconnected()) {
                        if (this.selfconnection.gater) {
                            if (input.gater) {
                                buildSentence(trace, ' = ', self_gain, ' * ', self_weight, ' * ', trace, ' + ', input_gain, ' * ', input_activation, store_trace);
                            } else {
                                buildSentence(trace, ' = ', self_gain, ' * ', self_weight, ' * ', trace, ' + ', input_activation, store_trace);
                            }
                        } else {
                            if (input.gater) {
                                buildSentence(trace, ' = ', self_weight, ' * ', trace, ' + ', input_gain, ' * ', input_activation, store_trace);
                            } else {
                                buildSentence(trace, ' = ', self_weight, ' * ', trace, ' + ', input_activation, store_trace);
                            }
                        }
                    } else {
                        if (input.gater) {
                            buildSentence(trace, ' = ', input_gain, ' * ', input_activation, store_trace);
                        } else {
                            buildSentence(trace, ' = ', input_activation, store_trace);
                        }
                    }
                    for (id in this.trace.extended) {
                        if (this.trace.extended.hasOwnProperty(id)) {
                            // extended elegibility trace
                            xtrace = this.trace.extended[id];
                            neuron = this.neighboors[id];
                            influence = getVar('influences[' + neuron.ID + ']');
                            neuron_old = getVar(neuron, 'old');
                            trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                            xtrace = getVar(this, 'trace', 'extended', neuron.ID, input.ID, this.trace.extended[neuron.ID][input.ID]);
                            if (neuron.selfconnected()) {
                                neuron_self_weight = getVar(neuron.selfconnection, 'weight');
                            }
                            if (neuron.selfconnection.gater) {
                                neuron_self_gain = getVar(neuron.selfconnection, 'gain');
                            }
                            if (neuron.selfconnected()) {
                                if (neuron.selfconnection.gater) {
                                    buildSentence(xtrace, ' = ', neuron_self_gain, ' * ', neuron_self_weight, ' * ', xtrace, ' + ', derivative, ' * ', trace, ' * ', influence, store_trace);
                                } else {
                                    buildSentence(xtrace, ' = ', neuron_self_weight, ' * ', xtrace, ' + ', derivative, ' * ', trace, ' * ', influence, store_trace);
                                }
                            } else {
                                buildSentence(xtrace, ' = ', derivative, ' * ', trace, ' * ', influence, store_trace);
                            }
                        }
                    }
                }
            }
            var gated_gain;
            for (connection in this.connections.gated) {
                if (this.connections.gated.hasOwnProperty(connection)) {
                    gated_gain = getVar(this.connections.gated[connection], 'gain');
                    buildSentence(gated_gain, ' = ', activation, store_activation);
                }
            }
        }
        if (!isInput) {
            var responsibility = getVar(this, 'error', 'responsibility', this.error.responsibility);
            if (isOutput) {
                var target = getVar('target');
                buildSentence(responsibility, ' = ', target, ' - ', activation, store_propagation);
                for (id in this.connections.inputs) {
                    if (this.connections.inputs.hasOwnProperty(id)) {
                        input = this.connections.inputs[id];
                        trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                        input_weight = getVar(input, 'weight');
                        buildSentence(input_weight, ' += ', rate, ' * (', responsibility, ' * ', trace, ')', store_propagation);
                    }
                }
                outputs.push(activation.id);
            } else {
                if (!noProjections && !noGates) {
                    var error = getVar('aux');
                    for (id in this.connections.projected) {
                        if (this.connections.projected.hasOwnProperty(id)) {
                            connection = this.connections.projected[id];
                            neuron = connection.to;
                            connection_weight = getVar(connection, 'weight');
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            if (connection.gater) {
                                connection_gain = getVar(connection, 'gain');
                                buildSentence(error, ' += ', neuron_responsibility, ' * ', connection_gain, ' * ', connection_weight, store_propagation);
                            } else {
                                buildSentence(error, ' += ', neuron_responsibility, ' * ', connection_weight, store_propagation);
                            }
                        }
                    }
                    var projected = getVar(this, 'error', 'projected', this.error.projected);
                    //should check derivative var
                    buildSentence(projected, ' = ', derivative, ' * ', error, store_propagation);
                    buildSentence(error, ' = 0', store_propagation);
                    for (id in this.trace.extended) {
                        if (this.trace.extended.hasOwnProperty(id)) {
                            neuron = this.neighboors[id];
                            influence = getVar('aux_2');
                            neuron_old = getVar(neuron, 'old');
                            if (neuron.selfconnection.gater === this) {
                                buildSentence(influence, ' = ', neuron_old, store_propagation);
                            } else {
                                buildSentence(influence, ' = 0', store_propagation);
                            }
                            for (input in this.trace.influences[neuron.ID]) {
                                if (this.trace.influences[neuron.ID].hasOwnProperty(input)) {
                                    connection = this.trace.influences[neuron.ID][input];
                                    connection_weight = getVar(connection, 'weight');
                                    neuron_activation = getVar(connection.from, 'activation');
                                    buildSentence(influence, ' += ', connection_weight, ' * ', neuron_activation, store_propagation);
                                }
                            }
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            buildSentence(error, ' += ', neuron_responsibility, ' * ', influence, store_propagation);
                        }
                    }
                    var gated = getVar(this, 'error', 'gated', this.error.gated);
                    buildSentence(gated, ' = ', derivative, ' * ', error, store_propagation);
                    buildSentence(responsibility, ' = ', projected, ' + ', gated, store_propagation);
                    for (id in this.connections.inputs) {
                        if (this.connections.inputs.hasOwnProperty(id)) {
                            input = this.connections.inputs[id];
                            gradient = getVar('aux');
                            trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                            buildSentence(gradient, ' = ', projected, ' * ', trace, store_propagation);
                            for (id in this.trace.extended) {
                                if (this.trace.extended.hasOwnProperty(id)) {
                                    neuron = this.neighboors[id];
                                    neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                                    xtrace = getVar(this, 'trace', 'extended', neuron.ID, input.ID, this.trace.extended[neuron.ID][input.ID]);
                                    buildSentence(gradient, ' += ', neuron_responsibility, ' * ', xtrace, store_propagation);
                                }
                            }
                            input_weight = getVar(input, 'weight');
                            buildSentence(input_weight, ' += ', rate, ' * ', gradient, store_propagation);
                        }
                    }
                } else if (noGates) {
                    buildSentence(responsibility, ' = 0', store_propagation);
                    for (id in this.connections.projected) {
                        if (this.connections.projected.hasOwnProperty(id)) {
                            connection = this.connections.projected[id];
                            neuron = connection.to;
                            connection_weight = getVar(connection, 'weight');
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            if (connection.gater) {
                                connection_gain = getVar(connection, 'gain');
                                buildSentence(responsibility, ' += ', neuron_responsibility, ' * ', connection_gain, ' * ', connection_weight, store_propagation);
                            } else {
                                buildSentence(responsibility, ' += ', neuron_responsibility, ' * ', connection_weight, store_propagation);
                            }
                        }
                    }
                    buildSentence(responsibility, ' *= ', derivative, store_propagation);
                    for (id in this.connections.inputs) {
                        if (this.connections.inputs.hasOwnProperty(id)) {
                            input = this.connections.inputs[id];
                            trace = getVar(this, 'trace', 'elegibility', input.ID, this.trace.elegibility[input.ID]);
                            input_weight = getVar(input, 'weight');
                            buildSentence(input_weight, ' += ', rate, ' * (', responsibility, ' * ', trace, ')', store_propagation);
                        }
                    }
                } else if (noProjections) {
                    buildSentence(responsibility, ' = 0', store_propagation);
                    for (id in this.trace.extended) {
                        if (this.trace.extended.hasOwnProperty(id)) {
                            neuron = this.neighboors[id];
                            influence = getVar('aux');
                            neuron_old = getVar(neuron, 'old');
                            if (neuron.selfconnection.gater === this) {
                                buildSentence(influence, ' = ', neuron_old, store_propagation);
                            } else {
                                buildSentence(influence, ' = 0', store_propagation);
                            }
                            for (input in this.trace.influences[neuron.ID]) {
                                if (this.trace.influences[neuron.ID].hasOwnProperty(input)) {
                                    connection = this.trace.influences[neuron.ID][input];
                                    connection_weight = getVar(connection, 'weight');
                                    neuron_activation = getVar(connection.from, 'activation');
                                    buildSentence(influence, ' += ', connection_weight, ' * ', neuron_activation, store_propagation);
                                }
                            }
                            neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                            buildSentence(responsibility, ' += ', neuron_responsibility, ' * ', influence, store_propagation);
                        }
                    }
                    buildSentence(responsibility, ' *= ', derivative, store_propagation);
                    for (id in this.connections.inputs) {
                        if (this.connections.inputs.hasOwnProperty(id)) {
                            input = this.connections.inputs[id];
                            gradient = getVar('aux');
                            buildSentence(gradient, ' = 0', store_propagation);
                            for (id in this.trace.extended) {
                                if (this.trace.extended.hasOwnProperty(id)) {
                                    neuron = this.neighboors[id];
                                    neuron_responsibility = getVar(neuron, 'error', 'responsibility', neuron.error.responsibility);
                                    xtrace = getVar(this, 'trace', 'extended', neuron.ID, input.ID, this.trace.extended[neuron.ID][input.ID]);
                                    buildSentence(gradient, ' += ', neuron_responsibility, ' * ', xtrace, store_propagation);
                                }
                            }
                            input_weight = getVar(input, 'weight');
                            buildSentence(input_weight, ' += ', rate, ' * ', gradient, store_propagation);
                        }
                    }
                }
            }
            buildSentence(bias, ' += ', rate, ' * ', responsibility, store_propagation);
        }
        return {
            memory: varID,
            neurons: neurons + 1,
            inputs: inputs,
            outputs: outputs,
            targets: targets,
            variables: variables,
            activation_sentences: activation_sentences,
            trace_sentences: trace_sentences,
            propagation_sentences: propagation_sentences,
            layers: layers
        };
    }
};
// represents a connection between two neurons
Neuron.connection = function Connection(from, to, weight) {
    if (!from || !to) {
        throw new Error('Connection Error: Invalid neurons');
    }
    this.ID = Neuron.connection.uid();
    this.from = from;
    this.to = to;
    this.weight = weight === undefined ? Math.random() * 0.2 - 0.1 : weight;
    this.gain = 1;
    this.gater = null;
};
// squashing functions
Neuron.squash = {};
// eq. 5 & 5'
Neuron.squash.LOGISTIC = function (x, derivate) {
    if (!derivate) {
        return 1 / (1 + Math.exp(-x));
    }
    var fx = Neuron.squash.LOGISTIC(x);
    return fx * (1 - fx);
};
Neuron.squash.TANH = function (x, derivate) {
    if (derivate) {
        return 1 - Math.pow(Neuron.squash.TANH(x), 2);
    }
    var eP = Math.exp(x);
    var eN = 1 / eP;
    return (eP - eN) / (eP + eN);
};
Neuron.squash.IDENTITY = function (x, derivate) {
    return derivate ? 1 : x;
};
Neuron.squash.HLIM = function (x, derivate) {
    return derivate ? 1 : x > 0 ? 1 : 0;
};
Neuron.squash.RELU = function (x, derivate) {
    if (derivate) {
        return x > 0 ? 1 : 0;
    }
    return x > 0 ? x : 0;
};
// unique ID's
(function () {
    var neurons = 0;
    var connections = 0;
    Neuron.uid = function () {
        neurons = neurons + 1;
        return neurons - 1;
    };
    Neuron.connection.uid = function () {
        connections = connections + 1;
        return connections - 1;
    };
    Neuron.quantity = function () {
        return {
            neurons: neurons,
            connections: connections
        };
    };
}());
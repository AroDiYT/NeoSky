'use strict';
/*global Network*/
/*global escape: true */
/*jslint bitwise: true */
/*jslint evil: true */
// export
if (module) {
    //CHECK THIS GLOBAL VAR
    module.exports = Network;
}
// import
var Neuron = require('./neuron');
var Layer = require('./layer');
/*******************************************************************************************
                                         NETWORK
*******************************************************************************************/
function Network(layers) {
    if (layers !== undefined) {
        this.layers = layers || {
            input: null,
            hidden: {},
            output: null
        };
        this.optimized = null;
    }
}
Network.prototype = {
    // feed-forward activation of all the layers to produce an ouput
    activate: function (input) {
        var layer;
        if (this.optimized === false) {
            this.layers.input.activateNeurons(input);
            for (layer in this.layers.hidden) {
                if (this.layers.hidden.hasOwnProperty(layer)) {
                    this.layers.hidden[layer].activateNeurons();
                }
            }
            return this.layers.output.activateNeurons();
        }
        if (!this.optimized) {
            this.optimize();
        }
        return this.optimized.activate(input);
    },
    // back-propagate the error thru the network
    propagate: function (rate, target) {
        if (this.optimized === false) {
            this.layers.output.propagate(rate, target);
            var reverse = [];
            var layer;
            for (layer in this.layers.hidden) {
                if (this.layers.hidden.hasOwnProperty(layer)) {
                    reverse.push(this.layers.hidden[layer]);
                }
            }
            reverse.reverse();
            for (layer in reverse) {
                if (reverse.hasOwnProperty(layer)) {
                    reverse[layer].propagate(rate);
                }
            }
        } else {
            if (!this.optimized) {
                this.optimize();
            }
            this.optimized.propagate(rate, target);
        }
    },
    // project a connection to another unit (either a network or a layer)
    project: function (unit, type, weights) {
        if (this.optimized) {
            this.optimized.reset();
        }
        if (unit instanceof Network) {
            return this.layers.output.project(unit.layers.input, type, weights);
        }
        if (unit instanceof Layer) {
            return this.layers.output.project(unit, type, weights);
        }
        throw new Error('Invalid argument, you can only project connections to LAYERS and NETWORKS!');
    },
    // let this network gate a connection
    gate: function (connection, type) {
        if (this.optimized) {
            this.optimized.reset();
        }
        this.layers.output.gate(connection, type);
    },
    // clear all elegibility traces and extended elegibility traces (the network forgets its context, but not what was trained)
    clear: function () {
        this.restore();
        var inputLayer = this.layers.input;
        var outputLayer = this.layers.output;
        inputLayer.clear();
        var layer;
        var hiddenLayer;
        for (layer in this.layers.hidden) {
            if (this.layers.hidden.hasOwnProperty(layer)) {
                hiddenLayer = this.layers.hidden[layer];
                hiddenLayer.clear();
            }
        }
        outputLayer.clear();
        if (this.optimized) {
            this.optimized.reset();
        }
    },
    // reset all weights and clear all traces (ends up like a new network)
    reset: function () {
        this.restore();
        var inputLayer = this.layers.input;
        var outputLayer = this.layers.output;
        inputLayer.reset();
        var layer;
        var hiddenLayer;
        for (layer in this.layers.hidden) {
            if (this.layers.hidden.hasOwnProperty(layer)) {
                hiddenLayer = this.layers.hidden[layer];
                hiddenLayer.reset();
            }
        }
        outputLayer.reset();
        if (this.optimized) {
            this.optimized.reset();
        }
    },
    // hardcodes the behaviour of the whole network into a single optimized function
    optimize: function () {
        var that = this;
        var optimized = {};
        var neurons = this.neurons();
        var i;
        var neuron;
        var layer;
        for (i in neurons) {
            if (neurons.hasOwnProperty(i)) {
                neuron = neurons[i].neuron;
                layer = neurons[i].layer;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                optimized = neuron.optimize(optimized, layer);
            }
        }
        for (i in optimized.propagation_sentences) {
            if (optimized.propagation_sentences.hasOwnProperty(i)) {
                optimized.propagation_sentences[i].reverse();
            }
        }
        optimized.propagation_sentences.reverse();
        var hardcode = '';
        hardcode += 'var F = Float64Array ? new Float64Array(' + optimized.memory + ') : []; ';
        for (i in optimized.variables) {
            if (optimized.variables.hasOwnProperty(i)) {
                hardcode += 'F[' + optimized.variables[i].id + '] = ' + (optimized.variables[i].value || 0) + '; ';
            }
        }
        hardcode += 'var activate = function(input){\n';
        for (i in optimized.inputs) {
            if (optimized.inputs.hasOwnProperty(i)) {
                hardcode += 'F[' + optimized.inputs[i] + '] = input[' + i + ']; ';
            }
        }
        var currentLayer;
        var currentNeuron;
        for (currentLayer in optimized.activation_sentences) {
            if (optimized.activation_sentences.hasOwnProperty(currentLayer)) {
                if (optimized.activation_sentences[currentLayer].length > 0) {
                    for (currentNeuron in optimized.activation_sentences[currentLayer]) {
                        if (optimized.activation_sentences[currentLayer].hasOwnProperty(currentNeuron)) {
                            hardcode += optimized.activation_sentences[currentLayer][currentNeuron].join(' ');
                            hardcode += optimized.trace_sentences[currentLayer][currentNeuron].join(' ');
                        }
                    }
                }
            }
        }
        hardcode += ' var output = []; ';
        for (i in optimized.outputs) {
            if (optimized.outputs.hasOwnProperty(i)) {
                hardcode += 'output[' + i + '] = F[' + optimized.outputs[i] + ']; ';
            }
        }
        hardcode += 'return output; }; ';
        hardcode += 'var propagate = function(rate, target){\n';
        hardcode += 'F[' + optimized.variables.rate.id + '] = rate; ';
        for (i in optimized.targets) {
            if (optimized.targets.hasOwnProperty(i)) {
                hardcode += 'F[' + optimized.targets[i] + '] = target[' + i + ']; ';
            }
        }
        for (currentLayer in optimized.propagation_sentences) {
            if (optimized.propagation_sentences.hasOwnProperty(currentLayer)) {
                for (currentNeuron in optimized.propagation_sentences[currentLayer]) {
                    if (optimized.propagation_sentences[currentLayer].hasOwnProperty(currentNeuron)) {
                        hardcode += optimized.propagation_sentences[currentLayer][currentNeuron].join(' ') + ' ';
                    }
                }
            }
        }
        hardcode += ' };\n';
        hardcode += 'var ownership = function(memoryBuffer){\nF = memoryBuffer;\nthis.memory = F;\n};\n';
        hardcode += 'return {\nmemory: F,\nactivate: activate,\npropagate: propagate,\nownership: ownership\n};';
        hardcode = hardcode.split(';').join(';\n');
        var constructor = new Function(hardcode);
        var network = constructor();
        network.data = {
            variables: optimized.variables,
            activate: optimized.activation_sentences,
            propagate: optimized.propagation_sentences,
            trace: optimized.trace_sentences,
            inputs: optimized.inputs,
            outputs: optimized.outputs,
            check_activation: this.activate,
            check_propagation: this.propagate
        };
        network.reset = function () {
            if (that.optimized) {
                that.optimized = null;
                that.activate = network.data.check_activation;
                that.propagate = network.data.check_propagation;
            }
        };
        this.optimized = network;
        this.activate = network.activate;
        this.propagate = network.propagate;
    },
    // restores all the values from the optimized network the their respective objects in order to manipulate the network
    restore: function () {
        if (!this.optimized) {
            return;
        }
        var optimized = this.optimized;
        var getValue = function () {
            var args = Array.prototype.slice.call(arguments);
            var unit = args.shift();
            var prop = args.pop();
            var id = prop + '_';
            var property;
            for (property in args) {
                if (args.hasOwnProperty(property)) {
                    id += args[property] + '_';
                }
            }
            id += unit.ID;
            var memory = optimized.memory;
            var variables = optimized.data.variables;
            if (variables.hasOwnProperty(id)) {
                return memory[variables[id].id];
            }
            return 0;
        };
        var list = this.neurons();
        var i;
        var neuron;
        var input;
        var gated;
        var j;
        var connection;
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                neuron.state = getValue(neuron, 'state');
                neuron.old = getValue(neuron, 'old');
                neuron.activation = getValue(neuron, 'activation');
                neuron.bias = getValue(neuron, 'bias');
                for (input in neuron.trace.elegibility) {
                    if (neuron.trace.elegibility.hasOwnProperty(input)) {
                        neuron.trace.elegibility[input] = getValue(neuron, 'trace', 'elegibility', input);
                    }
                }
                for (gated in neuron.trace.extended) {
                    if (neuron.trace.extended.hasOwnProperty(gated)) {
                        for (input in neuron.trace.extended[gated]) {
                            if (neuron.trace.extended[gated].hasOwnProperty(input)) {
                                neuron.trace.extended[gated][input] = getValue(neuron, 'trace', 'extended', gated, input);
                            }
                        }
                    }
                }
            }
        }
        // get connections
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                for (j in neuron.connections.projected) {
                    if (neuron.connections.projected.hasOwnProperty(j)) {
                        connection = neuron.connections.projected[j];
                        connection.weight = getValue(connection, 'weight');
                        connection.gain = getValue(connection, 'gain');
                    }
                }
            }
        }
    },
    // returns all the neurons in the network
    neurons: function () {
        var neurons = [];
        var inputLayer = this.layers.input.neurons();
        var outputLayer = this.layers.output.neurons();
        var neuron;
        var layer;
        var hiddenLayer;
        for (neuron in inputLayer) {
            if (inputLayer.hasOwnProperty(neuron)) {
                neurons.push({
                    neuron: inputLayer[neuron],
                    layer: 'input'
                });
            }
        }
        for (layer in this.layers.hidden) {
            if (this.layers.hidden.hasOwnProperty(layer)) {
                hiddenLayer = this.layers.hidden[layer].neurons();
                for (neuron in hiddenLayer) {
                    if (hiddenLayer.hasOwnProperty(neuron)) {
                        neurons.push({
                            neuron: hiddenLayer[neuron],
                            layer: layer
                        });
                    }
                }
            }
        }
        for (neuron in outputLayer) {
            if (outputLayer.hasOwnProperty(neuron)) {
                neurons.push({
                    neuron: outputLayer[neuron],
                    layer: 'output'
                });
            }
        }
        return neurons;
    },
    // returns number of inputs of the network
    inputs: function () {
        return this.layers.input.size;
    },
    // returns number of outputs of hte network
    outputs: function () {
        return this.layers.output.size;
    },
    // sets the layers of the network
    set: function (layers) {
        this.layers = layers;
        if (this.optimized) {
            this.optimized.reset();
        }
    },
    setOptimize: function (bool) {
        this.restore();
        if (this.optimized) {
            this.optimized.reset();
        }
        this.optimized = bool ? null : false;
    },
    // returns a json that represents all the neurons and connections of the network
    toJSON: function () {
        this.restore();
        var list = this.neurons();
        var neurons = [];
        var connections = [];
        // link id's to positions in the array
        var ids = {};
        var i;
        var neuron;
        var copy;
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                ids[neuron.ID] = i;
                copy = {
                    trace: {
                        elegibility: {},
                        extended: {}
                    },
                    state: neuron.state,
                    old: neuron.old,
                    activation: neuron.activation,
                    bias: neuron.bias,
                    layer: list[i].layer
                };
                copy.squash = neuron.squash === Neuron.squash.LOGISTIC ? 'LOGISTIC' : neuron.squash === Neuron.squash.TANH ? 'TANH' : neuron.squash === Neuron.squash.IDENTITY ? 'IDENTITY' : neuron.squash === Neuron.squash.HLIM ? 'HLIM' : null;
                neurons.push(copy);
            }
        }
        // get connections
        var j;
        var connection;
        for (i in list) {
            if (list.hasOwnProperty(i)) {
                neuron = list[i].neuron;
                while (neuron.neuron) {
                    neuron = neuron.neuron;
                }
                for (j in neuron.connections.projected) {
                    if (neuron.connections.projected.hasOwnProperty(j)) {
                        connection = neuron.connections.projected[j];
                        connections.push({
                            from: ids[connection.from.ID],
                            to: ids[connection.to.ID],
                            weight: connection.weight,
                            gater: connection.gater ? ids[connection.gater.ID] : null
                        });
                    }
                }
                if (neuron.selfconnected()) {
                    connections.push({
                        from: ids[neuron.ID],
                        to: ids[neuron.ID],
                        weight: neuron.selfconnection.weight,
                        gater: neuron.selfconnection.gater ? ids[neuron.selfconnection.gater.ID] : null
                    });
                }
            }
        }
        return {
            neurons: neurons,
            connections: connections
        };
    },
    // export the topology into dot language which can be visualized as graphs using dot
    // example: ... console.log(net.toDotLang());$ node example.js > example.dot;$ dot example.dot -Tpng > out.png
    toDot: function (edgeConnection) {
        if (!edgeConnection || edgeConnection === undefined) {
            edgeConnection = false;
        }
        var code = 'digraph nn {\n    rankdir = BT\n';
        var layers = [this.layers.input].concat(this.layers.hidden, this.layers.output);
        var layer;
        var to;
        var connection;
        var layerTo;
        var size;
        var layerID;
        var layerToID;
        var fakeNode;
        var from;
        var layerfrom;
        var layerfromID;
        for (layer in layers) {
            if (layers.hasOwnProperty(layer)) {
                for (to in layers[layer].connectedTo) {
                    if (layers[layer].connectedTo.hasOwnProperty(to)) {
                        // projections
                        connection = layers[layer].connectedTo[to];
                        layerTo = connection.to;
                        size = connection.size;
                        layerID = layers.indexOf(layers[layer]);
                        layerToID = layers.indexOf(layerTo);
                        /* http://stackoverflow.com/questions/26845540/connect-edges-with-graph-dot
                         * DOT does not support edge-to-edge connections
                         * This workaround produces somewhat weird graphs ...
                         */
                        if (edgeConnection) {
                            if (connection.gatedfrom.length) {
                                fakeNode = 'fake' + layerID + '_' + layerToID;
                                code += '    ' + fakeNode + ' [label = "", shape = point, width = 0.01, height = 0.01]\n';
                                code += '    ' + layerID + ' -> ' + fakeNode + ' [label = ' + size + ', arrowhead = none]\n';
                                code += '    ' + fakeNode + ' -> ' + layerToID + '\n';
                            } else {
                                code += '    ' + layerID + ' -> ' + layerToID + ' [label = ' + size + ']\n';
                            }
                            for (from in connection.gatedfrom) {
                                if (connection.gatedfrom.hasOwnProperty(from)) {
                                    // gatings
                                    layerfrom = connection.gatedfrom[from].layer;
                                    layerfromID = layers.indexOf(layerfrom);
                                    code += '    ' + layerfromID + ' -> ' + fakeNode + ' [color = blue]\n';
                                }
                            }
                        } else {
                            code += '    ' + layerID + ' -> ' + layerToID + ' [label = ' + size + ']\n';
                            for (from in connection.gatedfrom) {
                                if (connection.gatedfrom.hasOwnProperty(from)) {
                                    // gatings
                                    layerfrom = connection.gatedfrom[from].layer;
                                    layerfromID = layers.indexOf(layerfrom);
                                    code += '    ' + layerfromID + ' -> ' + layerToID + ' [color = blue]\n';
                                }
                            }
                        }
                    }
                }
            }
        }
        code += '}\n';
        return {
            code: code,
            link: 'https://chart.googleapis.com/chart?chl=' + escape(code.replace('/ /g', '+')) + '&cht=gv'
        };
    },
    // returns a function that works as the activation of the network and can be used without depending on the library
    standalone: function () {
        if (!this.optimized) {
            this.optimize();
        }
        var data = this.optimized.data;
        // build activation function
        var activation = 'function (input) {\n';
        // build inputs
        var i;
        var neuron;
        var sentence;
        for (i in data.inputs) {
            if (data.inputs.hasOwnProperty(i)) {
                activation += 'F[' + data.inputs[i] + '] = input[' + i + '];\n';
            }
        }
        // build network activation
        for (neuron in data.activate) {
            if (data.activate.hasOwnProperty(neuron)) {
                // shouldn't this be layer?
                for (sentence in data.activate[neuron]) {
                    if (data.activate[neuron].hasOwnProperty(sentence)) {
                        activation += data.activate[neuron][sentence].join('') + '\n';
                    }
                }
            }
        }
        // build outputs
        activation += 'var output = [];\n';
        for (i in data.outputs) {
            if (data.outputs.hasOwnProperty(i)) {
                activation += 'output[' + i + '] = F[' + data.outputs[i] + '];\n';
            }
        }
        activation += 'return output;\n}';
        // reference all the positions in memory
        var memory = activation.match(/F\[(\d+)\]/g);
        var dimension = 0;
        var ids = {};
        var address;
        var tmp;
        for (address in memory) {
            if (memory.hasOwnProperty(address)) {
                tmp = memory[address].match(/\d+/)[0];
                if (!ids.hasOwnProperty(tmp)) {
                    ids[tmp] = dimension;
                    dimension = dimension + 1;
                }
            }
        }
        var hardcode = 'F = {\n';
        for (i in ids) {
            if (ids.hasOwnProperty(i)) {
                hardcode += ids[i] + ': ' + this.optimized.memory[i] + ',\n';
            }
        }
        hardcode = hardcode.substring(0, hardcode.length - 2) + '\n};\n';
        hardcode = 'var run = ' + activation.replace(/F\[(\d+)\]/g, function (index) {
            return 'F[' + ids[index.match(/\d+/)[0]] + ']';
        }).replace('{\n', '{\n' + hardcode) + ';\n';
        hardcode += 'return run';
        // return standalone function
        return new Function(hardcode)();
    },
    worker: function () {
        /*global Blob*/
        /*global window*/
        /*global Worker*/
        if (!this.optimized) {
            this.optimize();
        }
        var hardcode = 'var inputs = ' + this.optimized.data.inputs.length + ';\n';
        hardcode += 'var outputs = ' + this.optimized.data.outputs.length + ';\n';
        hardcode += 'var F = null;\n';
        hardcode += 'var activate = ' + this.optimized.activate.toString() + ';\n';
        hardcode += 'var propagate = ' + this.optimized.propagate.toString() + ';\n';
        hardcode += 'onmessage = function(e){\n';
        hardcode += 'F = e.data.memoryBuffer;\n';
        hardcode += 'if (e.data.action == \'activate\'){\n';
        hardcode += 'if (e.data.input.length == inputs){\n';
        hardcode += 'postMessage( { action: \'activate\', output: activate(e.data.input), memoryBuffer: F }, [F.buffer]);\n';
        hardcode += '}\n}\nelse if (e.data.action == \'propagate\'){\n';
        hardcode += 'propagate(e.data.rate, e.data.target);\n';
        hardcode += 'postMessage({ action: \'propagate\', memoryBuffer: F }, [F.buffer]);\n';
        hardcode += '}\n}\n';
        var blob = new Blob([hardcode]);
        var blobURL = window.URL.createObjectURL(blob);
        return new Worker(blobURL);
    },
    // returns a copy of the network
    clone: function () {
        return Network.fromJSON(this.toJSON());
    }
};
// rebuild a network that has been stored in a json using the method toJSON()
Network.fromJSON = function (json) {
    var neurons = [];
    var layers = {
        input: new Layer(),
        hidden: [],
        output: new Layer()
    };
    var neuron;
    var config;
    var i;
    for (i in json.neurons) {
        if (json.neurons.hasOwnProperty(i)) {
            config = json.neurons[i];
            neuron = new Neuron();
            neuron.trace.elegibility = {};
            neuron.trace.extended = {};
            neuron.state = config.state;
            neuron.old = config.old;
            neuron.activation = config.activation;
            neuron.bias = config.bias;
            neuron.squash = Neuron.squash.hasOwnProperty(config.squash) ? Neuron.squash[config.squash] : Neuron.squash.LOGISTIC;
            neurons.push(neuron);
            if (config.layer === 'input') {
                layers.input.addNeuron(neuron);
            } else if (config.layer === 'output') {
                layers.output.addNeuron(neuron);
            } else {
                if (layers.hidden[config.layer] === undefined) {
                    layers.hidden[config.layer] = new Layer();
                }
                layers.hidden[config.layer].addNeuron(neuron);
            }
        }
    }
    var from;
    var to;
    var weight;
    var gater;
    var connection;
    for (i in json.connections) {
        if (json.connections.hasOwnProperty(i)) {
            config = json.connections[i];
            from = neurons[config.from];
            to = neurons[config.to];
            weight = config.weight;
            gater = neurons[config.gater];
            connection = from.project(to, weight);
            if (gater) {
                gater.gate(connection);
            }
        }
    }
    return new Network(layers);
};
// export
'use strict';
/*global Trainer*/
if (module) {
    module.exports = Trainer;
}
/*******************************************************************************************
                                        TRAINER
*******************************************************************************************/
function Trainer(network, options) {
    options = options || {};
    this.network = network;
    this.rate = options.rate || 0.2;
    this.iterations = options.iterations || 100000;
    this.error = options.error || 0.005;
    this.cost = options.cost || null;
    this.crossValidate = options.crossValidate || null;
}
Trainer.prototype = {
    // trains any given set to a network
    train: function (set, options) {
        /*jslint nomen: true */
        var error = 1;
        var bucketSize = 0;
        var iterations = 0;
        var abort = false;
        var currentRate;
        var cost;
        if (options && options.cost) {
            cost = options.cost;
        } else if (this.cost) {
            cost = this.cost;
        } else if (Trainer.cost.MSE) {
            cost = Trainer.cost.MSE;
        }
        var crossValidate = false;
        var testSet;
        var trainSet;
        var start = Date.now();

        function shuffle(o) {
            //v1.0
            var j;
            var x;
            var i;
            var n = 0;
            for (i = o.length; i; j = Math.floor(Math.random() * i), i = i - 1, x = o[i], o[i] = o[j], o[j] = x) {
                n = n + 1;
            }
            return o;
        }
        if (options) {
            if (options.iterations) {
                this.iterations = options.iterations;
            }
            if (options.error) {
                this.error = options.error;
            }
            if (options.rate) {
                this.rate = options.rate;
            }
            if (options.cost) {
                this.cost = options.cost;
            }
            if (options.schedule) {
                this.schedule = options.schedule;
            }
            if (options.customLog) {
                // for backward compatibility with code that used customLog
                console.log('Deprecated: use schedule instead of customLog');
                this.schedule = options.customLog;
            }
            if (this.crossValidate) {
                crossValidate = true;
                if (options.crossValidate.testSize) {
                    this.crossValidate.testSize = options.crossValidate.testSize;
                }
                if (options.crossValidate.testError) {
                    this.crossValidate.testError = options.crossValidate.testError;
                }
            }
        }
        currentRate = this.rate;
        if (Array.isArray(this.rate)) {
            bucketSize = Math.floor(this.iterations / this.rate.length);
        }
        if (crossValidate) {
            var numTrain = Math.ceil((1 - this.crossValidate.testSize) * set.length);
            trainSet = set.slice(0, numTrain);
            testSet = set.slice(numTrain);
        }
        var currentSetSize;
        var currentBucket;
        while (!abort && iterations < this.iterations && error > this.error) {
            if (crossValidate && error <= this.crossValidate.testError) {
                break;
            }
            currentSetSize = set.length;
            error = 0;
            if (bucketSize > 0) {
                currentBucket = Math.floor(iterations / bucketSize);
                currentRate = this.rate[currentBucket] || currentRate;
            }
            if (crossValidate) {
                this.trainSet(trainSet, currentRate, cost);
                error += this.test(testSet).error;
                currentSetSize = 1;
            } else {
                error += this.trainSet(set, currentRate, cost);
                currentSetSize = set.length;
            }
            // check error
            iterations = iterations + 1;
            error /= currentSetSize;
            if (options) {
                if (this.schedule && this.schedule.every && iterations % this.schedule.every === 0) {
                    abort = this.schedule.do({
                        error: error,
                        iterations: iterations,
                        rate: currentRate
                    });
                } else if (options.log && iterations % options.log === 0) {
                    console.log('iterations', iterations, 'error', error, 'rate', currentRate);
                }
                if (options.shuffle) {
                    shuffle(set);
                }
            }
        }
        var results = {
            error: error,
            iterations: iterations,
            time: Date.now() - start
        };
        return results;
    },
    // preforms one training epoch and returns the error (private function used in this.train)
    trainSet: function (set, currentRate, costFunction) {
        var input;
        var target;
        var output;
        var errorSum = 0;
        var train;
        for (train in set) {
            if (set.hasOwnProperty(train)) {
                input = set[train].input;
                target = set[train].output;
                output = this.network.activate(input);
                this.network.propagate(currentRate, target);
                errorSum += costFunction(target, output);
            }
        }
        return errorSum;
    },
    // tests a set and returns the error and elapsed time
    test: function (set, options) {
        var error = 0;
        var input, output, target;
        var cost;
        if (options && options.cost) {
            cost = options.cost;
        } else if (this.cost) {
            cost = this.cost;
        } else if (Trainer.cost.MSE) {
            cost = Trainer.cost.MSE;
        }
        var start = Date.now();
        var test;
        for (test in set) {
            if (set.hasOwnProperty(test)) {
                input = set[test].input;
                target = set[test].output;
                output = this.network.activate(input);
                error += cost(target, output);
            }
        }
        error /= set.length;
        var results = {
            error: error,
            time: Date.now() - start
        };
        return results;
    },
    // trains any given set to a network using a WebWorker
    workerTrain: function (set, callback, options) {
        var that = this;
        var error = 1;
        var bucketSize = 0;
        var iterations = 0;
        var currentRate;
        var length = set.length;
        var abort = false;
        var cost;
        if (options && options.cost) {
            cost = options.cost;
        } else if (this.cost) {
            cost = this.cost;
        } else if (Trainer.cost.MSE) {
            cost = Trainer.cost.MSE;
        }
        var start = Date.now();

        function shuffle(o) {
            //v1.0
            var j;
            var x;
            var i;
            var n;
            for (n = 0, i = o.length; i; j = Math.floor(Math.random() * i), i = i - 1, x = o[i], o[i] = o[j], o[j] = x) {
                n = n + 1;
            }
            return o;
        }
        if (options) {
            if (options.iterations) {
                that.iterations = options.iterations;
            }
            if (options.error) {
                that.error = options.error;
            }
            if (options.rate) {
                that.rate = options.rate;
            }
            if (options.cost) {
                that.cost = options.cost;
            }
            if (options.schedule) {
                that.schedule = options.schedule;
            }
            if (options.customLog) {
                // for backward compatibility with code that used customLog
                console.log('Deprecated: use schedule instead of customLog');
                that.schedule = options.customLog;
            }
        }
        // dynamic learning rate
        currentRate = that.rate;
        if (Array.isArray(that.rate)) {
            bucketSize = Math.floor(that.iterations / that.rate.length);
        }
        // create a worker
        var worker = that.network.worker();
        // activate the network
        function activateWorker(input) {
            worker.postMessage({
                action: 'activate',
                input: input,
                memoryBuffer: that.network.optimized.memory
            }, [that.network.optimized.memory.buffer]);
        }
        // backpropagate the network
        function propagateWorker(target) {
            if (bucketSize > 0) {
                var currentBucket = Math.floor(iterations / bucketSize);
                currentRate = that.rate[currentBucket] || currentRate;
            }
            worker.postMessage({
                action: 'propagate',
                target: target,
                rate: currentRate,
                memoryBuffer: that.network.optimized.memory
            }, [that.network.optimized.memory.buffer]);
        }
        var index;
        // train the worker
        worker.onmessage = function (e) {
            // give control of the memory back to the network
            that.network.optimized.ownership(e.data.memoryBuffer);
            if (e.data.action === 'propagate') {
                if (index >= length) {
                    index = 0;
                    iterations = iterations + 1;
                    error /= set.length;
                    // log
                    if (options) {
                        if (that.schedule && that.schedule.every && iterations % that.schedule.every === 0) {
                            abort = that.schedule.do({
                                error: error,
                                iterations: iterations,
                                rate: currentRate
                            });
                        } else if (options.log && iterations % options.log === 0) {
                            console.log('iterations', iterations, 'error', error);
                        }
                        if (options.shuffle) {
                            shuffle(set);
                        }
                    }
                    if (!abort && iterations < that.iterations && error > that.error) {
                        activateWorker(set[index].input);
                    } else {
                        // callback
                        callback({
                            error: error,
                            iterations: iterations,
                            time: Date.now() - start
                        });
                    }
                    error = 0;
                } else {
                    activateWorker(set[index].input);
                }
            }
            if (e.data.action === 'activate') {
                error += cost(set[index].output, e.data.output);
                propagateWorker(set[index].output);
                index = index + 1;
            }
        };
        // kick it
        index = 0;
        activateWorker(set[index].input);
    },
    // trains an XOR to the network
    XOR: function (options) {
        if (this.network.inputs() !== 2 || this.network.outputs() !== 1) {
            throw new Error('Incompatible network (2 inputs, 1 output)');
        }
        var defaults = {
            iterations: 100000,
            log: false,
            shuffle: true,
            cost: Trainer.cost.MSE
        };
        if (options) {
            var i;
            for (i in options) {
                if (options.hasOwnProperty(i)) {
                    defaults[i] = options[i];
                }
            }
        }
        return this.train([{
            input: [
                0,
                0
            ],
            output: [0]
        }, {
            input: [
                1,
                0
            ],
            output: [1]
        }, {
            input: [
                0,
                1
            ],
            output: [1]
        }, {
            input: [
                1,
                1
            ],
            output: [0]
        }], defaults);
    },
    // trains the network to pass a Distracted Sequence Recall test
    DSR: function (options) {
        options = options || {};
        var targets = options.targets || [
            2,
            4,
            7,
            8
        ];
        var distractors = options.distractors || [
            3,
            5,
            6,
            9
        ];
        var prompts = options.prompts || [
            0,
            1
        ];
        var length = options.length || 24;
        var criterion = options.success || 0.95;
        var iterations = options.iterations || 100000;
        var rate = options.rate || 0.1;
        var log = options.log || 0;
        var schedule = options.schedule || {};
        var cost = options.cost || this.cost || Trainer.cost.CROSS_ENTROPY;
        var success = 0;
        var j = 0;
        var i = 0;
        var correct = 0;
        var trial = 0,
            error = 1,
            symbols = targets.length + distractors.length + prompts.length;
        var noRepeat = function (range, avoid) {
            /*jslint bitwise: true */
            var number = Math.random() * range | 0;
            var used = false;
            var p;
            for (p in avoid) {
                if (avoid.hasOwnProperty(p)) {
                    if (number === avoid[p]) {
                        used = true;
                    }
                }
            }
            return used ? noRepeat(range, avoid) : number;
        };
        var equal = function (prediction, output) {
            var p;
            for (p in prediction) {
                if (prediction.hasOwnProperty(p)) {
                    if (Math.round(prediction[p]) !== output[p]) {
                        return false;
                    }
                }
            }
            return true;
        };
        var start = Date.now();
        var sequence;
        var sequenceLength;
        var any;
        var indexes;
        var positions;
        var distractorsCorrect;
        var targetsCorrect;
        var input;
        var output;
        var index;
        var prediction;
        var divideError;
        while (trial < iterations && (success < criterion || trial % 1000 !== 0)) {
            // generate sequence
            sequence = [];
            sequenceLength = length - prompts.length;
            for (i = 0; i < sequenceLength; i = i + 1) {
                /*jslint bitwise: true */
                any = Math.random() * distractors.length | 0;
                sequence.push(distractors[any]);
            }
            indexes = [];
            positions = [];
            for (i = 0; i < prompts.length; i = i + 1) {
                indexes.push(Math.random() * targets.length | 0);
                positions.push(noRepeat(sequenceLength, positions));
            }
            positions = positions.sort();
            for (i = 0; i < prompts.length; i = i + 1) {
                sequence[positions[i]] = targets[indexes[i]];
                sequence.push(prompts[i]);
            }
            //train sequence
            targetsCorrect = 0;
            distractorsCorrect = 0;
            error = 0;
            for (i = 0; i < length; i = i + 1) {
                // generate input from sequence
                input = [];
                for (j = 0; j < symbols; j = j + 1) {
                    input[j] = 0;
                }
                input[sequence[i]] = 1;
                // generate target output
                output = [];
                for (j = 0; j < targets.length; j = j + 1) {
                    output[j] = 0;
                }
                if (i >= sequenceLength) {
                    index = i - sequenceLength;
                    output[indexes[index]] = 1;
                }
                // check result
                prediction = this.network.activate(input);
                if (equal(prediction, output)) {
                    if (i < sequenceLength) {
                        distractorsCorrect = distractorsCorrect + 1;
                    } else {
                        targetsCorrect = targetsCorrect + 1;
                    }
                } else {
                    this.network.propagate(rate, output);
                }
                error += cost(output, prediction);
                if (distractorsCorrect + targetsCorrect === length) {
                    correct = correct + 1;
                }
            }
            // calculate error
            if (trial % 1000 === 0) {
                correct = 0;
            }
            trial = trial + 1;
            divideError = trial % 1000;
            divideError = divideError === 0 ? 1000 : divideError;
            success = correct / divideError;
            error /= length;
            // log
            if (log && trial % log === 0) {
                console.log('iterations:', trial, ' success:', success, ' correct:', correct, ' time:', Date.now() - start, ' error:', error);
            }
            if (schedule.do && schedule.every && trial % schedule.every === 0) {
                schedule.do({
                    iterations: trial,
                    success: success,
                    error: error,
                    time: Date.now() - start,
                    correct: correct
                });
            }
        }
        return {
            iterations: trial,
            success: success,
            error: error,
            time: Date.now() - start
        };
    },
    // train the network to learn an Embeded Reber Grammar
    ERG: function (options) {
        options = options || {};
        var iterations = options.iterations || 150000;
        var criterion = options.error || 0.05;
        var rate = options.rate || 0.1;
        var log = options.log || 500;
        var cost = options.cost || this.cost || Trainer.cost.CROSS_ENTROPY;
        // gramar node
        var Node = function () {
            this.paths = [];
        };
        Node.prototype = {
            connect: function (node, value) {
                this.paths.push({
                    node: node,
                    value: value
                });
                return this;
            },
            any: function () {
                /*jslint bitwise: true */
                if (this.paths.length === 0) {
                    return false;
                }
                var index = Math.random() * this.paths.length | 0;
                return this.paths[index];
            },
            test: function (value) {
                var i;
                for (i in this.paths) {
                    if (this.paths.hasOwnProperty(i)) {
                        if (this.paths[i].value === value) {
                            return this.paths[i];
                        }
                    }
                }
                return false;
            }
        };
        var reberGrammar = function () {
            // build a reber grammar
            var output = new Node();
            var n1 = new Node().connect(output, 'E');
            var n2 = new Node().connect(n1, 'S');
            var n3 = new Node().connect(n1, 'V').connect(n2, 'P');
            var n4 = new Node().connect(n2, 'X');
            n4.connect(n4, 'S');
            var n5 = new Node().connect(n3, 'V');
            n5.connect(n5, 'T');
            n2.connect(n5, 'X');
            var n6 = new Node().connect(n4, 'T').connect(n5, 'P');
            var input = new Node().connect(n6, 'B');
            return {
                input: input,
                output: output
            };
        };
        // build an embeded reber grammar
        var embededReberGrammar = function () {
            var reber1 = reberGrammar();
            var reber2 = reberGrammar();
            var output = new Node();
            var n1 = new Node().connect(output, 'E');
            reber1.output.connect(n1, 'T');
            reber2.output.connect(n1, 'P');
            var n2 = new Node().connect(reber1.input, 'P').connect(reber2.input, 'T');
            var input = new Node().connect(n2, 'B');
            return {
                input: input,
                output: output
            };
        };
        // generate an ERG sequence
        var generate = function () {
            var node = embededReberGrammar().input;
            var next = node.any();
            var str = '';
            while (next) {
                str += next.value;
                next = next.node.any();
            }
            return str;
        };
        // test if a string matches an embeded reber grammar
        var test = function (str) {
            var node = embededReberGrammar().input;
            var i = 0;
            var ch = str.charAt(i);
            var next;
            while (i < str.length) {
                next = node.test(ch);
                if (!next) {
                    return false;
                }
                node = next.node;
                i = i + 1;
                ch = str.charAt(i);
            }
            return true;
        };
        // helper to check if the output and the target vectors match
        var different = function (array1, array2) {
            var max1 = 0;
            var i1 = -1;
            var max2 = 0;
            var i2 = -1;
            var i;
            for (i in array1) {
                if (array1.hasOwnProperty(i)) {
                    if (array1[i] > max1) {
                        max1 = array1[i];
                        i1 = i;
                    }
                    if (array2[i] > max2) {
                        max2 = array2[i];
                        i2 = i;
                    }
                }
            }
            return i1 !== i2;
        };
        var iteration = 0;
        var error = 1;
        var table = {
            'B': 0,
            'P': 1,
            'T': 2,
            'X': 3,
            'S': 4,
            'E': 5
        };
        var start = Date.now();
        var i;
        var sequence;
        var read;
        var predict;
        var input;
        var target;
        var j;
        var output;
        while (iteration < iterations && error > criterion) {
            i = 0;
            error = 0;
            // ERG sequence to learn
            sequence = generate();
            // input
            read = sequence.charAt(i);
            // target
            predict = sequence.charAt(i + 1);
            // train
            while (i < sequence.length - 1) {
                input = [];
                target = [];
                for (j = 0; j < 6; j = j + 1) {
                    input[j] = 0;
                    target[j] = 0;
                }
                input[table[read]] = 1;
                target[table[predict]] = 1;
                output = this.network.activate(input);
                if (different(output, target)) {
                    this.network.propagate(rate, target);
                }
                i = i + 1;
                read = sequence.charAt(i);
                predict = sequence.charAt(i + 1);
                error += cost(target, output);
            }
            error /= sequence.length;
            iteration = iteration + 1;
            if (iteration % log === 0) {
                console.log('iterations:', iteration, ' time:', Date.now() - start, ' error:', error);
            }
        }
        return {
            iterations: iteration,
            error: error,
            time: Date.now() - start,
            test: test,
            generate: generate
        };
    },
    timingTask: function (options) {
        if (this.network.inputs() !== 2 || this.network.outputs() !== 1) {
            throw new Error('Invalid Network: must have 2 inputs and one output');
        }
        if (options === undefined) {
            options = {};
        }
        // helper
        function getSamples(trainingSize, testSize) {
            // sample size
            var size = trainingSize + testSize;
            // generate samples
            var t = 0;
            var set = [];
            var i;
            for (i = 0; i < size; i = i + 1) {
                set.push({
                    input: [
                        0,
                        0
                    ],
                    output: [0]
                });
            }
            var n;
            var j;
            var k;
            while (t < size - 20) {
                n = Math.round(Math.random() * 20);
                set[t].input[0] = 1;
                for (j = t; j <= t + n; j = j + 1) {
                    set[j].input[1] = n / 20;
                    set[j].output[0] = 0.5;
                }
                t += n;
                n = Math.round(Math.random() * 20);
                for (k = t + 1; k <= t + n && k < size; k = k + 1) {
                    set[k].input[1] = set[t].input[1];
                }
                t += n;
            }
            // separate samples between train and test sets
            var trainingSet = [];
            var testSet = [];
            var l;
            for (l = 0; l < size; l = l + 1) {
                (l < trainingSize ? trainingSet : testSet).push(set[l]);
            }
            // return samples
            return {
                train: trainingSet,
                test: testSet
            };
        }
        var iterations = options.iterations || 200;
        var error = options.error || 0.005;
        var rate = options.rate || [
            0.03,
            0.02
        ];
        var log = options.log === false ? false : options.log || 10;
        var cost = options.cost || this.cost || Trainer.cost.MSE;
        var trainingSamples = options.trainSamples || 7000;
        var testSamples = options.trainSamples || 1000;
        // samples for training and testing
        var samples = getSamples(trainingSamples, testSamples);
        // train
        var result = this.train(samples.train, {
            rate: rate,
            log: log,
            iterations: iterations,
            error: error,
            cost: cost
        });
        return {
            train: result,
            test: this.test(samples.test)
        };
    }
};
// Built-in cost functions
Trainer.cost = {
    // Eq. 9
    CROSS_ENTROPY: function (target, output) {
        var crossentropy = 0;
        var i;
        for (i in output) {
            if (output.hasOwnProperty(i)) {
                crossentropy -= target[i] * Math.log(output[i] + 1e-15) + (1 - target[i]) * Math.log(1 + 1e-15 - output[i]); // +1e-15 is a tiny push away to avoid Math.log(0)
            }
        }
        return crossentropy;
    },
    MSE: function (target, output) {
        var mse = 0;
        var i;
        for (i in output) {
            if (output.hasOwnProperty(i)) {
                mse += Math.pow(target[i] - output[i], 2);
            }
        }
        return mse / output.length;
    },
    BINARY: function (target, output) {
        var misses = 0;
        var i;
        for (i in output) {
            if (output.hasOwnProperty(i)) {
                misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);
            }
        }
        return misses;
    }
};